* * * JavaScript * * *  

>> Библиотека - дополнительные фу-и для построения UI.

>> Фреймворк - настраивает, обеспечивает дополнительную структуру и возможности, оптимизирует приложение.

>>  Для хранения number выделяется 64 бита: 52 - для чисел, 11 - для положения десятичной точки, 1 - для знака.

>>  Object.is(NaN, NaN)   // true
>>  Object.is(0, -0)      // false
>>  NaN === NaN           // false
>>  null == undefined     // true   // Равны друг другу и не равны любому другому значению
>>  null > 0              // false  
>>  null == 0             // false  
>>  null >= 0             // true   
>>  undefined > 0         // false  // undefined преобразуется в NaN
>>  'some' > 'string'     // false  // Строки сравниваются посимвольно

>>  1 / 3                 // 0.3333333333333333
>>  10 / 3                // 3.3333333333333335 (округляет до ближайшего возможного согласно формату IEEE 754)
>>  NaN ** 0              // 1
>>  1 / 0                 // Infinity
>>  1 / 4                 // 0.25
>>  "str" / 2             // NaN (При любых математических операциях со строками вернет NaN, кроме +)
>>  1 + NaN               // NaN
>>  1 + '2'               // '12'
>>  '2' - 1               // 1
>>  true + false          // 1
>>  true + true           // 2
>>  undefined + undefined // NaN
>>  null + null           // 0
>>  NaN + NaN             // NaN
>>  [] + []               // '' (пустая строка)

>>  typeof(Math)          // object 
>>  typeof(null)          // object
>>  typeof(alert)         // function

>>  String(true)          // "true"
>>  String(null)          // "null"
>>  String(undefined)     // "undefined"

>>  Number(undefined)     // NaN
>>  Number(null)          // 0

>>  Boolean('0')          // true
>>  Boolean('')           // false
>>  Boolean(NaN)          // false
>>  Boolean(null)         // false
>>  Boolean(undefined)    // false

>> a ^ b ^ b === a
>> ~n === -(n + 1)
>> ' a << n ' === a * 2**b
>> ' a >> n ' === a / 2**b (крайний-левый бит (знак числа) не меняется)

>>  Область видимости `var` ограничивается функцией
>>  if (false) var phrase - переменная phrase создасться, поскольку объявления var всплывают в начало фу-и
>>  == и Boolean() используют разные правила приведения типов

>>  Полифил - аналог метода в спецификации, который не поддерживается в более старой версией движка
>>  Инкапсуляция - разделение интерфейса на внутренний и внешний

>> str.padStart(length, str) - заполняет начало целевой строки заданной строкой, пока длинна целевой строки не достигнет заданной длины.
>> str.padEnd(length, str) - как padStart, только заполняет в с конца.

*           Инструкция по написанию метода
      1. Написать подробный тест на метод.
      2. Описать принцип, при помощи которого метод решает задачу.
      3. Написать тело метода.

*           Инструкция по созданию приложения
      1. Описать проект:
            - основные цели.
            - содержание проекта (cтраницы, функционал, зависимости).
      2. Изобразить структуру страницы прямоугольниками.
      3. Нарисовать макет.
      4. Изобразить иерархию компонетов.
      5. Написать статическое приложение.
      6. Приступить к написанию логики компонентов.

*           Атаки
      1. clickjacking - позволяет вредоносной странице кликнуть на сайте-жертве.
      Принцип: 
            на вредоносной странице размещается прозрачный <iframe src="сайт-жертва.com">, 
            при попытке кликнуть по желаемому элементу пользователь на самом деле кликнет по iframe.
      Защита:
            - HTTP-заголовок X-Frame-Option: SAMEORIGIN
            - перекрывающий div

*           Составляющие приложения:
      1. User Interface - как пользователь будет взаимодействовать с приложением
      2. Routing - как пользователь будет перемещаться между разными частями приложения
      3. Data Fetching - где хранить данные и как их получить
      4. Rendering - когда и где рендерить статический и динамический контент
      5. Integrations - какие сторонние сервисы использовать и как к ним подключаться (CMS, auth, payments)
      6. Infrastructure - где выкладывать, хранить и запускать приложение
      7. Performance - как оптимизировать приложение для конечного пользователя
      8. Scalability - до какой степени приложение будет масштабируемым (ко-во пользователей и кода)
      9. Developer Experience


////////////////////////////
1.   Основные типы данных   
////////////////////////////

      1. Number (спец. числовые значения: Infinity, -Infinity, NaN)                     

      2. BigInt (для работы с целыми числами произвольной длинны; добавить n в конце числа)

      3. String

      4. Boolean

      5. Null         

      6. Undefined

      7. Symbol

      8. Object

>> Виды записей переменных:
      1. PascalCase - типы и классы
      2. DB_PASSWORD - константные значения
      2. camelCase - все остальное
  
>> Унарный ' + ' не работает с BigInt числами

>> Ṩ === 'S\u0307\u0323' (Ṩ === S + точка сверху + точка снизу)


////////////////////////////
2.   Преобразование типов   
////////////////////////////

      1.  Строковое (String(value))
      2.  Числовое (Number(value), '6' / '2' = 3)
      3.  Логическое (Boolean(value))


/////////////////
3.   Операторы   
/////////////////

- унарные
- бинарные
- сравнения
- логические


++value   > возвращает новое значение

value++   > возвращает старое значение

==        > преобразуют операнды к числу

===       > проверяет равенство без приведения типов

||        > возвращает первое истинное значение, либо последнее при всех false

||=       > Логическое присваивание ИЛИ - если операнд слева falsy, то ему присваивается операнд справа

&&        > возвращает первое ложное значение, либо последнее при всех true

&&=       > Логическое присваивание И - если операнд слева truthy, то ему присваивается операнд справа

??        > Оператор нулевого слияния (Nullish coalescing operator) - возвращает первый аргумент,
            если он не null/undefined. Запрещено использовать с && и ||
            result = a ?? b - эквивалент записи - result = (a !== null && a !== undefined) ? a : b

??=       > Оператор нулевого присваивания - если операнд слева undefined/null, то ему присваивается операнд справа

?.        > Оператор опциональной последовательности 
            (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining)


>> Побитовые операторы работают с 32-битными целыми со знаком, старшим битом слева и дополнением до двойки:
      - страший бит слева - от большего разряда к меньшему
      - дополнение до двойки - в отрицательных числах биты противоположны положительным числам и добавлена 1

>> obj.method() - оператор . возвращает Reference Type (ссылочный тип), который передает оператору () информацию о this.
      Если оператор . используется в каком-либо выражении отдельно от оператора (), то Reference Type теряет исходный this.
      Одним из решений данной проблемы является метод bind().

>> Оператор Spread - копирует собственные перечисляемые свойства объекта (без прототипа) в новый объект:
      let obj = { a: 1, b: 2 }
      let newObj = { ...obj }


/////////////
4.   Циклы   
/////////////

>> Циклы игнорируют СИМВОЛЬНЫЕ и НЕПЕРЕЧИСЛИМЫЕ свойства объектов

>> Директивы break/continue поддерживают метки, чтобы выйти из любого уровня вложенности циклов:
      labelName: for (...) {
        ...
        break/continue labelName;
      }


///////////////
5.   Функции   
///////////////

      1. Function Declaration                          : function foo() {} 
            > В Lexical Environment инициализируется мгновенно и полностью
      
      2. Function Expression                           : let foo = function() {} 
            > Не имеет        this
            > Не имеет        super
            > Не имеет        "arguments"
            > Не могут        быть вызваны с new

      3. Named Function Expression (NFE)               : let foo = function bar() {} 
            > Function Expression с именем;
            > Для рекурсивных вызовов;
            > Недоступна за пределами фу-и.

      4. new Function([arg1, ..., argN], functionBody) : let foo = new Function('a', 'b', 'return a + b')
            > Имеет [[Environment]], ссылающийся на глобальное лексическое окружение.

      5. Tagged Template String Literal (теговый шаблон) - tag`first str ${arg1} and ${arg2} third str`.
            > function tag(strings, ...expressions) {} 
                  > strings       - массив строк между ${expression}.
                  > expressions   - массив выражений ${expression}.
                  > strings.raw() - исходная строка.


>> new.target - исп. внутри фу-и, чтобы проверить вызвана ли фу-я при помощи new
>> isNaN() и isFinite() отличаются от Number.isNaN() и Number.isFinite()
>> Object.is() идентичен === , кроме 2-х случаев
>> parseInt('100px', 10) === 100
>> str.codePointAt(pos) // код символа на позиции pos
>> String.fromCodePoint(code)
>> foo.name - имя фу-и
>> foo.length - ко-во аргументов в объявлении фу-и. Остаточные параметры не считаются
>> call  - принимает список аргументов
>> apply - принимает псевдомассив
>> bind  - возвращает экзотический объект bound function, который фиксирует контекст и аргументы только во время создания
>> [].join.call(arguments) // пример заимствования метода с помощью call
>> window.eval(str) - выполняет строку кода str и возвращает результат последнего line. 
                      При `use strict` имеет свое lexical environment.


>> Контекст выполнения - спец. внутренняя структура данных, которая содержит информацию о вызове фу-и 
    (место логического курсора, локальные переменные фу-и, значение this и пр.)

>> Применение рекурсии:
      - рекурсивные обходы (объект в объекте в объекте...)
      - рекурсивные структуры (связанный список)

>> arguments - подобный массиву объект содержащий ВСЕ переданные в фу-ю аргументы, не поддерживает методы массивов. 

>> Lexical Environment - объект спецификации: он описан в спецификации для описания того, 
                         как все работает, его нельзя получить

>> Переменная - свойство спец. внутр. объекта Environment Record (хранилище переменных).
                Поиск искомой переменной происходит сначала во внутреннем Lexical Environment, 
                затем во внешнем, и так до глобального объекта

>> Вложенный setTimeout гарантирует фиксированную задержку после выполнения фу-и

>> Браузер ограничивается 4 мс минимальной задерожки между более 4 вызовов setTimeout или setInterval

>> Декораторы (Decorators) - обертка вокруг фу-и, которая изменяет ее поведение

>> Частичное применение - создание новой фу-и с некоторыми фиксированными аргументами (double = multiple.bind(null, 2))

>> Каррирование - трансформация фу-и из f(a,b,c) в f(a)(b)(c). 
                  Можно создавать частично-примененные фу-и (т.к. каждый аргумент запоминает свою обл. видимости).
                  Только для фу-й с фиксированным количеством аргументов.


///////////////
6.   Объекты    
///////////////

>> null и undefined НЕ имеют объектов-оберток. У них нет свойств, методов, прототипов.

>> Все ключи объектов преобразуются в строки (кроме символов и строк).

>> this - указывает на объект перед точкой.

>> ?. - опциональная цепочка (optional chaining) - останавливает вычисление и возвращает undefined,
        если значение слева === undefined или === null 
        - работает только с объявленными объектами
        - работает только для ЧТЕНИЯ и УДАЛЕНИЯ
        - работает для вызова фу-и, которой может не существовать ( obj.method?.() )
        - работает для объектов со свойствами в квадратных скобках ( obj?.[prop] )

>> [Symbol.iterator]() {} - спец. метод объекта для настройки итерации объекта "вручную". 
                            Возвращает объект с методом next(), который вызывается на каждой итерации.

>> Варианты преобразования типов (хинты): 1. "string"
                                          2. "number"
                                          3. "default"

>> [Symbol.isConcatSpreadable]: true - спец. свойство объекта, которое указывает методу array.concat(obj) обрабатывать obj как массив.
                                       * Пример:
                                                let array = [1, 2]
                                                let obj = { 0: 'someValue', 1: 'anotherValue' }
                                                ( array.concat(obj) ) // 1, 2, someValue, anotherValue

>> [Symbol.toStringTag]: 'Value' - спец. свойство объекта для настройки toString у объектов.
                                   Это свойство есть у большей части встроенных объектов.
                                   Результат === значение этого свойства обернутое в [object Value].

>> Дескриптор свойства - объект, который содержит значение и флаги (атрибуты) свойства.
>> Атрибуты дескриптора для data properties: 
      - value 
      - writable        === false, value нельзя изменить
      - enumerable      === false, свойство игнорируется циклом, Object.keys
      - configurable    === false, нельзя удалить, нельзя изменить значение всех атрибутов с false на true

>> Object.getOwnPropertyDescriptor(obj, propName)       - возвращает дескриптор свойства.
>> Object.getOwnPropertyDescriptors(obj)                - возвращает объект, содержащий дескрипторы всех свойств.
>> Object.defineProperty(obj, propName, descriptor)     - возвращает obj.
>> Object.defineProperties(obj, { prop: descriptor })   - возвращает obj.
>> let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)) - клонирование объекта вместе с флагами.

>> Типы свойств:
      - Data properties (свойства-данные)
      - Accessor properties (свойства-аксессоры) 

>> Accessor properties - фу-и, которые исп. для получения и присвоения значения, но синтаксически выглядит как свойство объекта.
      let obj = {
            get propName() {}       - срабатывает при чтении obj.propName
            set propName(value) {}  - срабатывает при записи obj.propName = value 
      }
  
>> Атрибуты дескриптора для accessor properties:
      - get            // { get() { return this.name } }
      - set            // { set(value) { this.name = value } }
      - enumerable
      - configurable


>> Intl - объект c API интернационализации:
      > let collator  = Intl.Collator([locales, [options]])
      > let formatter = Intl.DateTimeFormat([locales, [options]])
      > let formatter = Intl.NumberFormat([locales, [options]])

>> Сильная ссылка - ссылка на объект, которая предотвращает его удаление сборщиком мусора.
>> Слабая ссылка  - ссылка на объект, которая НЕ предотвращает его удаление сборщиком мусора.
  
>> new WeakRef(target) - объект, содержащий слабую ссылку на target.
>> new FinalizationRegistry(cleanuCallback) - объект, который позволяет привязять к target колбэк очистки, 
                                                который выполниться после удаления target из памяти сборщиком мусора.


/////////////////
7.   Прототипы   
/////////////////

>> [[Prototype]] - скрытое свойство, либо === null, либо ссылается на другой объект - прототип
      - Замена [[Prototype]] в существующих объектах ОЧЕНЬ медленная операция ( Object.setPrototypeOf и obj.proto = )

>> obj.__proto__ - это getter/setter для [[Prototype]], то есть способ доступа до

>> Операции запись/удаление не работают с прототипом (за исключением свойства-аксессора setter)

>> this - указывает на объект перед точкой

>> Циклы учитывают унаследованные свойства
>> Object.keys, Object.values и др. - игнорируют унаследованные свойства

>> Foo.prototype = {}/null - определяет __proto__ только для экземпляров new Foo
      function Foo() {} > Foo.prototype = obj2 > let obj1 = new Foo() > obj.__proto__ === obj2
>> Foo.prototype === { constructor: Foo }
>> obj.__proto__ === arr.__proto__.__proto__ === func.__proto__.__proto__ === Number(5).__proto__.__proto__ === Object.prototype

>> obj.join = Array.prototype.join // пример заимствования метода с помощью prototype

>> Вместо __proto__ : 1. Object.create(proto, [descriptor])       // создает {} со свойством [[Prototype]] и дескриптором
                      2. Object.getPrototypeOf(obj)               // возвращает [[Prototype]]
                      3. Object.setPrototypeOf(obj, proto)        // устанавлиавает [[Prototype]]

>> let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))

>> Простейший объект (ассоциативный массив) - создается через new Map / Object.create(null) / obj.__proto__ = null 

>> obj['__proto__'] = 'someValue' // присвоение проигнорируется


//////////////
8.   Классы   
//////////////

>> Класс - шаблон кода для создания объектов, который устанавливает в них начальные свойства и методы

>> [[IsClassConstructor]]: true - спец. внутр. свойство фу-и, созданной с помощью class 
>> Методы и constructor - сохраняются в SomeClass.prototype
>> Методы класса неперечисляемы
>> Классы всегда используют 'use strict'
>> (Named) Class Expression - аналог (Named) Function Expression

>> class Child extends Parent : 
      - Child.prototype.__proto__ === Parent.prototype
      - после extends разрешены любые выражения

>> super.method() - вызывает родительский метод
>> super()        - вызывает конструктор родителя (работает только в дочернем конструкторе)

>> При отсутсвии конструктора, вызывается пустой конструктор ( constructor(...args) { super(...args) } )
>> Конструкторы в дочерних классах должны обязательно вызывать конструктор родителя ( super() ) перед использованием this 
>> [[ConstructorKind]]: 'derived' - спец. внутр. свойство функции-конструктора дочернего класса.
                                    Такой конструктор ожидает вызова конструктора родительского класса,
                                    который создаст пустой объект и присвоет его this.
                                    Поэтому, если мы создаем конструктор в дочернем классе, необходимо вызвать super,
                                    иначе объект для this не будет создан и мы получим ошибку.

>> Родительский конструктор всегда использует СВОЕ ЗНАЧЕНИЕ ПОЛЯ, а не переопределенное дочерним классом
>> Поля РОДИТЕЛЬСКОГО класса инициализируются перед конструктором
>> Поля ДОЧЕРНЕГО класса инициализируются после вызова super

>> [[HomeObject]] : 
      - спец. внутр. свойство методов класса (объекта) и оно равно этому классу (объекту)
      - используется только в super, чтобы получить прототип родителя и его методы
      - нельзя изменить, поэтому копировать метод использующий super, между объектами небезопасно
      - в объектах работает только в методах объявленных как method()

>> Статические свойства и методы класса - устанавливаются самому классу:
      - наследуются дочерним классом ( Child.[[Prototype]] = Parent ) 
      - НЕ наследются от встроенных классов
      - this === сам класс ( по аналогии с объектами )
      - экземплярам класса НЕДОСТУПНЫЕ
      - СИНТАКСИС: 
            1. class MyClass {
                  static property = ...
                  static method() { ... }
            };

            2. MyClass.property = ...
               MyClass.method   = ...
              
>> Защищенные методы и свойства - по соглашению JS-программистов:
      - доступны только внутри класса
      - начинаются с префикса ' _ '

>> Приватные методы и свойства:
      - начинаются со спец. символа ' # '
      - доступны исключительно внутри класса
      - не наследуются
      - не конфликтуют с публичными
      - не работает с this ( this['#prop'] - не работает )

>> Symbol.species - спец. статический getter, который должен вернуть конструктор,
                    который будет использован для создания новых объектов:
                    * Пример: 
                        class ExtendedArray extends Array {
                              static get [Symbol.species]() { return Array }
                        }           
                        let array = new ExtendedArray(1, 2, 3, 4, 5)
                        let filteredArray = array.filter(item => item >=3)
                        ( filteredArray.__proto__ === array.__proto__ ) // false
      
>> instanceof - оператор проверяет, принадлежит ли объект указанному классу, с учетом наследования
                Алгоритм работы: 
                        1. Если в классе есть статичный метод [Symbol.hasInstance], то вызвать его ( должен возвращать true/false):
                              * Пример:
                                    class Animal {
                                          static [Symbol.hasInstance](obj) { if (obj.catEat) return true }
                                    }
                                    let obj = { catEat }
                                    ( obj instanceof Animal ) // true

                        2. Проверка на равенство прототипа класса какому либо прототипу в прототипной цепочке объекта: 
                              ( Class.prototype === obj.__proto__ )
                              ( Class.prototype === obj.__proto__.__proto__ ) и т.д.

>> objA.isPrototypeOf(objB) - аналог instanceof: ( obj instanceof Class === Class.prototype.isPrototypeOf(obj) )

>> Примеси (Mixins) - класс, методы которого предназначены для расширения функциональности других классов без наследования от примеси.
                    - Примесь необходимо скопировать в прототип расширяемого класса ( Object.assign(ClassName.prototype, mixin) )
                    - Примесь перезаписывает существующие методы класса

>> JavaScript НЕ поддерживает множественное наследование. Вместо него используют Mixins


/////////////////////////
9.   Тип данных Symbol  
/////////////////////////

      1. Symbol.for(key) 
      2. Symbol.keyFor(symbol)
      3. Object.getOwnPropertySymbols(obj)
      4. Reflect.ownKeys(obj)
      5. Symbol.toPrimitive

>> Свойства, чьи ключи Символы игнорируются циклом for...in и Object.keys()


/////////////////
10.  Замыкание   
/////////////////

>> Замыкание - это фу-я, которая с помощью скрытого свойства [[Environment]] запоминает свои внешние 
               переменные и может получить к ним доступ. ( https://learn.javascript.ru/closure )

>> Пример:
      let f3 = f1()
      let f4 = f1()

      console.log(f3)
      console.log(f4)

      f3()
      f3()
      f3()
      f4()
      f4()
      f4()
      f4()

      function f1() {
            let x = 1
      
            return function f2() {
                  console.log(++x)
            }
      }


////////////////////////
11.  Обработка ошибок
////////////////////////

>> try {} catch() {} finally {} - работает синхронно, то есть ассинхронный код игнорируется
      - finally выполняется всегда, в т.ч. после return 
      - при возникновении ошибки JS генерирует объект ошибки и передает как аргумент в блок catch
      - catch должен обрабатывать только известные ему ошибки, а остальные пробрасывать ( throw error )

>> throw <объект ошибки> - оператор генерирующий ошибку

>> window.onerror = function (message, url, line, column, error) {} - глобальный catch

>> Сервисы для логирования ошибок:
      - https://errorception.com
      - http://www.muscula.com

>> Расширение встроенных классов ошибок:
      - class MyError extends Error
      - вызвать super
      - изменить name ( this.name = this.constructor.name - чтобы не прописывать вручную name)

>> instanceof - использовать для проверки типа ошибок (при расширении классов ошибок)

>> Обертывание исключений - алгоритм: фу-я ловит низкоуровневые исключения и создает 1 высокоуровневое
      

/////////////////////
12.  Асинхронность   
/////////////////////

>> new Promise(function(resolve, reject) { <executor> }).then(function(result) {}, function(error) {})
                                                        .catch(function(error) {})
                                                        .finally(function() {})

      1. executor       - фу-я-исполнитель, которая запускается сразу после создания Promise
      2. resolve(value) - встроенный callback, который необходимо вызвать при успешном выполнении executor
      3. reject(error)  - встроенный callback, который необходимо вызвать при ошибке в executor
      4. Объект класса Promise обладает внутренними свойствами:
            > state (состояние; может быть изменено только 1 раз): 
                  - pending   (ожидание)
                  - fulfilled (выполнено успешно)
                  - rejected  (выполнено с ошибкой)
            > result (в зависимости от state):
                  - при pending     === undefined
                  - при fulfilled   === value
                  - при rejected    === error
      5. then - возвращает Promise; then выполняет:
            > 1-й callback при state === fulfilled
                  - возвращаемое значение становится результатом выполнения Promise и передается в следующий .then 
            > 2-й callback при state === rejected
      6. catch - укороченный вариант для .then(null, function(error) {})
      7. finally - метод, который:
            > выполнится в любом случае
            > ничего не возвращает
            > пропускет result или error дальше, к следующему then/catch

            
>> Если callback в .then/.catch/.finally возвращает new Promise, последующие элементы цепочки ждут, пока выполнится new Promise

>> thenable - отличительный признак объекта содержащего метод .then, который можно вернуть как Promise.
              Если фу-я возвращает объект с пользовательским методом .then, то интерпретатор обрабатывает его
              как Promise и вызывает его метод .then, после чего передает ему встроенные resolve и reject

>> fetch - возвращает Promise, который возвращает объект response ПОСЛЕ того, как удаленный сервер присылает
           ЗАГОЛОВКИ ответа, но ДО того, как ВЕСЬ ОТВЕТ сервера полностью загружен

>> Скрытым try-catch - обладает фу-я Promise и callback - ошибки обрабатываются по ходу выполнения кода (синхронно)

>> Проброс ошибки (throw) в .catch работает аналогично пробросу в try-catch

>> 'unhandledrejection' - событие, которое срабатывает при наличии необработанных ошибок.
                          Возникает, когда все промисы (микрозадачи) завершены и какой-либо из них "rejected"
                          Основные свойства:
                              - event.promise // [object Promise] - Promise, который сгенерировал ошибку
                              - event.reason  // Объект ошибки, которая не была обработана

>> Методы класса Promise:
    1. Promise.all            - ждет, пока все переданные промисы выполнятся УСПЕШНО (или 1-ю ошибку)
    2. Promise.allSettled     - ждет, пока все переданные промисы ЗАВЕРШАТСЯ
    3. Promise.race           - ждет 1-й ЗАВЕРШЕННЫЙ промис
    4. Promise.any            - ждет 1-й УСПЕШНО выполненный промис
    5. Promise.resolve/reject - возвращает промис успешный/с ошибкой (async-await заменяет эти методы)

>> Промисификация - создание фу-и-обертки, которая принимает в качестве параметра callback
                    и возвращает Promise, который вызывает этот callback

>> PromiseJobs (mikrotask queue) - очередь микрозадач (.then/.catch/.finally попадают в очередь): 
                                   движок выполняет задачи из очереди, когда он выполнит основной код
                                    
>> async - оператор, который пишется перед объявлением фу-и, теперь эта фу-я всегда будет возвращать Promise
            - работает для методов класса
            - для обработки финального результата/ошибки использовать .then/.catch
            
>> await - оператор, который пишется перед Promise в async фу-и, теперь интерпретатор ждет, пока Promise не выполнится
            - работает с thenable-объектами
            - для обработки ошибок использовать try-catch
 
>> Условия для async-итерации:
      1. [Symbol.asyncIterator] - вместо [Symbol.iterator]
      2. next() - должен возвращать Promise
      3. Для итерации по объекту исп. только for await


//////////////////
13.  Генераторы
//////////////////

>> function* generateSequence() {         // при вызове возвращает спец. объект - генератор ( [object Generator] )
      yield 1
      yield 2
      return 3 // <!>
   }
   let generator = generateSequence()     // перебираемый объект ( <!> цикл не возвращает значение return )
   generator.next()                       // выполняет код фу-и до ближайшей инструкции ' yield ', после чего останавливается.
                                                Возвращает объект: 
                                                      { value: 'value', done: true/false }
                                                            - true в случае завершения выполнения фу-и ( или return )
      
>> Генераторы можно генерировать бесконечно ( например, с помощью цикла в теле функции-генератора )

>> Для создания перебираемых объектов обычно исп. генератор  - *[Symbol.iterator]
>> *[Symbol.iterator]() {} - сокращенная запись для [Symbol.iterator]: function* () {} 
      
>> yield* - инструкция, которая делегирует выполнение другому генератору
>> Композиция генераторов - возможность встраивать генераторы друг в друга с помощью инструкции ' yield* '
                            * Пример: 
                                    function* generateSequnce(start, end) {
                                          for (let i = start; i !== end; i++) yield i
                                    }
                                    function* generateAnotherSequence() {
                                          yield* generateSequence(1, 5)
                                          yield* generateSequence(5, 10)
                                    }

>> yield и next могут обмениваться значениями:
      - yield передает значение объекту, который возвращает текущий ' next '
      - next(arg) передает arg в генератор, после чего arg становиться результатом предыдущего выражения yield
            * Пример: 
                    console.log(yield 1) // generator.next().value  === 1           // в консоле выведет 4
                    console.log(yield 2) // generator.next(4).value === 2           // в консоле выведет 9
                    console.log(yield 3) // generator.next(9).value === 3           // в консоле выведет 16
                                         // generator.next(16).value === undefined

>> throw - метод инициирующий ошибку на последнем сработавшем yield (generator.throw(new Error()))
       
>> Async-генератор:
      - необходимо добавить async
      - next возвращает Promise 
      - перебирать генератор только с помощью for await 

>> Для создания async-перебираемых объектов обычно исп. async-генератор - async *[Symbol.asyncIterator]


//////////////
14.  Модули
//////////////

>> Модуль - файл со скриптом

>> export - отмечает переменные и фу-и, которые должны быть доступны вне модуля
>> import - импортирует функциональность из других модулей

>> Свойства модулей:
      1. В модуле всегда используется режим 'use strict'
      2. Каждый модуль имеет свою обл. видимости
      3. Импортируемый код выполняется 1 раз
      4. Изменения импортируемых данных видят все импортеры
      5. В модуле this === undefined ( в не-модуле this === window )
      6. Модули выполняются в отложенном режиме ( deferred ):
            - модули ожидают полной загрузки HTML
            - сохраняется порядок выполнения скриптов в документе
      7. Модули с одинаковым src выполняется 1 раз
      8. Модуль загружаемый с другого домена требует указания заголовков CORS

>> Рекомендуется явно указывать список импортируемого функционала - для легкой поддержки кода 

>> export default - экспорт по умолчанию: 
      - в модуле может быть только 1 такой экспорт
      - при импорте такого экспорта {} не нужны
      - экспортируемая сущность не обязана иметь имя
      - export { foo as default } - экспорт отдельно от объявления
      - при import * as foo, доступ к export default через foo.default

>> export ... from ... - реэкспорт:
      - позволяет импортировать функционал и одновременно его экспортировать 
      - исп. для возможности импортировать весь функционал из 1 "главного" файла

>> export { default } from ... - реэкспорт по умолчанию

>> import 'module' - запустит код импортируемого модуля

>> import('module') - динамический импорт:
      - загружает модуль и возвращает Promise
      - можно исп. в любом месте кода
      - работает в скрипте не-модуле
      - внутри async фу-и можно исп. await import('module')
      - это НЕ фу-я ( аналог super() )


////////////////////////////
15.  Регулярные выражения
////////////////////////////

>> Создание regexp:
      a. let regexp = new RegExp('шаблон', 'флаги')       // можно использовать переменные
      b. let regexp = /шаблон/флаги                       // только статичный текст
    
>> Флаги:
      i - поиск не зависит от регистра
      g - поиск ищет ВСЕ совпадения (иначе только первое)
      m - многострочный режим (только для якорей ^ и $, чтобы искать в каждой строке разделённых переносом строки \n)
      s - режим dotall ( . === /n)
      u - полная поддрежка Юникода
      y - поиск на конкретной позиции в тексте
      d - результат помещается в массив

>> Символьные Классы:
      \d - цифра (0-9)
      \s - пробельные символы
      \w - буквы латинского алфавита, цифры, _
      \p{...} - юникодные свойства, работает только с флагом u, описывают категорию символа: L, N, P, и т. д. 
            "123 test".match(/\p{L}/gu) === t,e,s,t
      .  - любой символ, кроме \n (с флагом s будет учитывать и \n)
      ^ - начало строки
            /^\d/.test("1. Test") === true
      $ - конец строки
            /st$/.test("2. Test") === true
      ^...$ - полное совпадение строки
            /^test$/.test("test") === true
      \b...\b - ищет слово (начинается на \w, заканчивается не \w)
            "JavaScript Java Script".match(/\bJava\b/g) === Java
      [...] - искать один символ соответствующий какому-либо из переданных (диапазону) символов, символьных классов
      [^...] - искать любые символы кроме указанных
            "abc".match(/[abc])    === a
            "abc".match(/a[a-z]/)  === ab
            "1bc".match(/[^0-9]+/) === bc
      | - альтернация, как [...], но работает не с символами, а с любыми выражениями
            "00:00 10:10 23:59 25:99 1:2".match(/([01]\d|2[0-3]):[0-5]\d/g) === 00:00, 10:10, 23:59

>> Квантификаторы - пишутся после символа, который нужно искать какое-то число раз
      + - 1 и более раз
      * - 0 и более раз
      ? - 0 или 1 раз
      {n} - n раз (после n через кому можно указать дополнительное число раз: {1,2} - 1 или 2 раза)

>> Обратный Символьный Класс - класс, который исключаюет другой соответствующий класс (Например: \D, \S, \W)

>> Методы:
      str.match(regexp) - ищет совпадения 
            - без скобочных групп
            - если совпадений нет, возвращает null

      str.matchAll(regexp) - ищет совпадения
            - со скобочными группами
            - возвращает перебираемый объект (Array.from, чтобы сделать из него массив)
            - если совпадений нет, возвращает пустой перебираемый объект

      str.replace(str|regexp, str|function) - универсальный метод поиска и замены в строке
            - во 2-м аргументе (строка замены) можно использовать спец. символы (см. Подстановки)
            - во 2-м аргументе может быть фу-я - её результат будет вставлен в качестве замены
                  > func(match, p1, ..., pn, offset, input, groups)
                        1. match - найденное совпадение
                        2. p1, ..., pn - содержимое скобочных групп
                        3. offset - позиция, на которой найдено совпадение
                        4. input - исходная строка
                        5. groups - объект с содержимым именованных скобочных групп

    
      str.split(regexp|substr, limit) - разбивает строку по разделителю regexp или substr
      str.search(regexp) - возвращает позицию 1-го совпадения или -1, если совпадений нет                 

      regexp.exec(str) - аналогичен str.match(regexp)
            > при наличии флага g
                  - regexp.lastIndex - позиция начала поиска каждого следующего совпадения
                  - если совпадений больше нет, то regexp.exec(str) возвращает null, а regexp.lastIndex === 0
            > при наличии флага y
                  - regexp.lastIndex - ищет исключительно на позиции lastIndex

      regexp.test(str) - если есть хоть одно совпадение, то возвращает true, иначе false
            !!! имеется свойство regexp.lastIndex
            !!! после использования lastIndex меняется на следующий

>> Для поиска символов [ ] \ ^ $ . | ? * + ( ) необходимо их экранировать

>> Символьные классы - сокращение для наборов символов:
      \d === [0-9]
      \w === [a-zA-Z0-9_]
      \s === [\t\n\v\f\r]

>> Режимы квантификаторов:
      1. Жадный  - повторяет квантификатор максимальное число раз. 
            Если строка закончилась, поиск возвратится до ближайшего совпадения оставшегося шаблона.
            Режим работает по умолчанию.
      2. Ленивый - ищет совпадения для оставшегося шаблона перед каждым повторением квантификатора.
            Режим включается знаком ? после квантификатора.

>> Скобочная группа:
      1. Квантификаторы применяются ко всему содержимому скобок
      2. Скобочные группы поочередно сохраняются в результируюющий массив (номерация начинается с 1):
            - не работает с флагом g
            - если скобочная группа необязательна (квантификатор ?), она все равно будет в результате как undefined
      3. str.matchAll(regexp):
            - возвращает перебираемый объект (Array.from(obj), for (let array of obj), [array1, array2] = obj)
            - с флагом g каждое совпадение это массив со скобочными группами
            - если совпадений нет, возвращает пустой перебираемый объект
      4. (?<name>...) - именование скобочной группы
            - именованные группы находятся в array.groups
      5. str.replace(regexp, replacement) - в строке замены replacement можно использовать содержимое скобочных групп:
            - по номеру скобочной группы ( $n )
                  >> 'aaa bbb'.replace(/(\w+) (\w+)/, '$2 $1') === 'bbb aaa'
            - по имени скобочной группы ( $<name> )
                  >> 'a b'.replace(/(?<name1>a) (b)/, '$name1 $name1') === 'a a'
      6. ?: - исключает содержимое скобочной группы из результата
            >> 'a b'.match(/(?:\w) (\w)/)
    
>> Обратные ссылки в шаблоне (доступ к скобочным граппам в шаблоне):
      \number - по номеру скобочной группы
      \<name> - по имени скобочной группы

>> Подстановки (шаблон замены - метод replace):
      $$ - подставляет знак $
      $& - подставляет совпадение полностью 
      $n - подставляет совпадение группы под номером n
      ${name} - подставляет совпадение группы с именем name

>> Проверки:
      - при нескольких проверках подряд для совпадения необходимо выполнение всех проверок
      - чтобы Y был в результате, его необходмо обернуть в скобки
            X(?=Y) - ищет X, если за ним Y
            X(?!Y) - ищет X, если за ним НЕ Y
            (?<=Y)X - ищет X, если перед ним Y
            (?<!Y)X - ищет X, если перед ним НЕ Y


///////////
16.  DOM
///////////

>> Document Object Model (DOM) - понятная для человека модель взаимосвязей фрагментов кода (объектов).

>> Свойства и методы:
+ Свойства узлов
      elem.nodeType           - тип узла. [number, read only].
      elem.tagName            - имя тега элемента. [read only].
      node.nodeName           - имя/тип узла. [read only].
      elem.innerHTML          - HTML-содержимое элемента.
      elem.outerHTML          - HTML-элемент. Изменятся элемент в DOM, но не содержимое переменной.
      textNode.data/nodeValue - содержимое ТЕКСТОВОГО узла.
      elem.textContent        - текст внутри элемента.
      
+ HTML-атрибуты
      elem.hasAttribute(name)        - проверить наличие атрибута.
      elem.getAttribute(name)        - получить значение атрибута.
      elem.setAttribute(name, value) - установить значения атрибута.
      elem.removeAttribute(name)     - удалить атрибут.
      elem.attributes                - коллекция атрибутов в виде объектов со свойствами name и value.

+ Поиск элементов:
      elem.matches(css)          - проверяет удовлетворяет ли элемент селектору CSS. [true/false].
      elem.closest(css)          - ищет ближайшего предка, включая сам элемент.
      elemA.contains(elemB)      - true, если elemB внутри elemA или elemA === elemB, иначе false.
      elem.querySelector(css)    - находит первый подходящий элемент.
      elem.querySelectorAll(css) - находит все подходящие элементы.
      elem.getElementById(id)    - находит элемент по id.
      elem.getElementsByClassName(class) -┐
      elem.getElementsByTagName(tag) -----|--> возвращают коллекцию, которая обновляется при изменениях.
      elem.getElementsByName(name) -------┘

+ Создание и изменения узлов
      document.createElement(tag)     - создать элемент с заданным тегом.
      document.creatTextNode(text)    - создать текстовый узел с заданным текстом.
      node.prepend(node | string)     - добавить узел в начало.
      node.append(node | string)      - добавить узел в конец.
      node.before(node | string)      - добавить узел перед узлом.
      node.after(node | string)       - добавить узел после узла.
      node.replaceWith(node | string) - заменить узел на заданный узел.
      node.remove()                   - удалить узел.
      node.cloneNode(true | false)    - возвращает клон элемента с/без дочерними элементами.
      insertAdjacentHTML(where, html)       - вставляет html    | where:
      insertAdjacentText(where, string)     - вставляет текст   |  beforebegin/afteend  - до/после элемента.
      insertAdjacentElement(where, element) - вставляет элемент |  afterbegin/beforeend - начало/конец элемента.

+ Стили и классы
      elem.style - спец. объект стилей. Имена свойств CSS в JS преобразуются по принципу: дефис -> большая буква.
!!!>               Оперирует только атрибутом style в HTML, не имеет доступа к стилям из <style> и файлов CSS.
      elem.style.cssText - строка, содержащая ассоциативный массив CSS. 'prop1: value1; prop2: value2;'
      elem.className     - строка с набором всех классов через пробел. 'class1 class2 class3'
      elem.classList     - перебираемый объект, содержащий список и методы добавления/удаления классов.
      elem.classList.add(string)      - добавить класс.
      elem.classList.remove(string)   - удалить класс.
      elem.classList.toggle(string)   - добавить класс, если его нет, удалить - если есть.
      elem.classList.contains(string) - проверяет наличие класса. [true/false].
      elem.style.anyProperty = "" - присвоить свойству пуйстую строку, чтобы сбросить стиль (вместо удаления).
      getComputedStyle(element, [pseupo]) - возвращает объект с вычисленными стилями.
                                            Аналог elem.style, но с учётом <style> и файлов CSS.
                                            Значения свойств всегда в абсолютных величинах (пиксели).
                                            Содержит только полные значения (paddingTop, но не padding).
                                            Не даёт доступа к псевдоклассу :visited.

+ Размеры и прокрутка элементов
      elem.getBoundingClientRect() - возвращает объект, содержащий координаты elem.
      document.elementFromPoint(x, y) - возвращает самый глубоко вложенный элемемент в окне по координатам.
      elem.offestParent - ближайший позиционированный предок элемента. null для элементов position: fixed.
      elem.offsetLeft/offsetTop - координаты относительно левого верхнего угла offsetParent. (read only).
      elem.offsetWidth/offsetHeight - ширина/высота элемента включая border. (read only).
      elem.clientLeft/clientTop - отступы внутренней части элемента от внешней (часто равны border). (read only).
      elem.clientWidth/clientHeight - контент + padding, без прокручиваемой области. (read only).
      elem.scrollWidth/scrollHeight - контент + padding, и вся прокручиваемая область. (read only).
      elem.scrollLeft/scrollTop - ширина/высота уже прокрученного контента.
!!!>  Не стоит брать width/height из CSS.
      document.documentElement.clientWidth/clientHeight - ширина/высота окна, за вычетом полосы прокрутки.
      window.innerWidth/innerHeight - ширина/высота окна браузера вместе с полосой прокрутки.
      window.pageXOffset/pageYOffset -| ширина/высота прокрученной области страницы.
      window.scrollX/scrollY ---------┘
      window.scrollBy(x, y) || (options) - прокручивает страницу ОТНОСИТЕЛЬНО её текущего положения. 
      window.scrollTo(x, y) || (options) - прокручивает страницу на АБСОЛЮТНЫЕ координаты. 
                                options === {
                                    top: x,
                                    left: y,
                                    behavior : "auto"||  "instant" || "smooth"
                                };
      elem.scrollIntoView(top) || (options) - прокручивает страницу так, чтобы elem находился вверху/внизу 
                                   options === {                                         (top = true/false).
                                          behavior:  "auto" || "instant" || "smooth",
                                          block: "start" || "center" || "end" || "nearest",
                                          inline: "start" || "center" || "end" || "nearest"
                                   };
!!!>  Получить полную высоту документа:
            let scrollHeight = Math.max(
                  document.body.scrollHeight, document.documentElement.scrollHeight,
                  document.body.offsetHeight, document.documentElement.offsetHeight,
                  document.body.clientHeight, document.documentElement.clientHeight
            );
      document.body.style.overflow = 'hidden' - делает документ не прокручиваемым, но исчезает полоса прокрутки.

+ Устаревшие методы и свойства
      parentElem.appendChild(node)               - добавить node в конец parentElem.
      parentElem.insertBefore(node, nextSibling) - добавить node перед nextSibling.
      parentElem.replaceChild(node, oldChild)    - заменить oldChild на node.
      parentElem.removeChild(node)               - удалить node.
      document.write(html) - во время загрузки страницы на ходу записывает в неё HTML (работает очень быстро).
                             Если вызвать после окончания загрузки страницы, её содержимое затрётся. 

>> Наборы ссылок:
      > Для всех узлов: childNodes, parentNode, firstChild, lastChild, previousSibling, nextSibling.
      > Для элементов: children, parentElement, firstElementChild, lastElementChild, previousElementChild, nextElementChild.

>> DOM-узлы представляют собой обычные объекты соответствующих классов.
   Классы DOM описываются в Interface Description Language (IDL).
   Пример классов DOM:
      1. EventTarget
      2. Node
      3. Element
      4. HTMLElement и т.п.

>> Особенности HTML-атрибутов:
      > Стандартные атрибуты в HTML-элементах соответствуют свойствам этих элементов в JS-коде.
      > HTML-атрибуты регистронезависимы и их значения всегда строки.
      > Значение некоторых HTML-атрибутов нельзя изменить в JS-коде.
      > data-атрибуты доступны в свойстве элемента dataset: 
            HTML: <a data-foo-bar="value"> ---> JS: a.dataset.fooBar

>> DocumentFragment - класс, позволяющий создавать обёртку вокруг набора узлов.
                      Когда обёртку куда-либо применяют, она исчезает и остаётся только её содержимое.


///////////////
17.  События
///////////////

>> Способы назначить обработчик событий:
      1. Атрибут элемента on<имясобытия>
      2. Свойство элемента on<имясобытия>
      3. elem.addEventListener(event, handler, [options]):
            > event - имя события
            > handler - ссылка на функцию, или объект класса с методом handleEvent(event) {}
            > options === 1. true/false - фаза срабатывания обработчика: погружение/всплытие
                          2. {
                                    once: true/false    - после выполнения обработчик удалить/неУдалять
                                    capture: true/false - фаза срабатывания обработчика: погружение/всплытие
                                    passive: true/false - если true, то сообщает браузеру, что обработчик не вызовет
                                                          preventDefault(), и браузер сразу выполнит действие по умолчанию, 
                                                          не ожидая других обработчиков.
                              }

> elem.removeEventListener(event, handler, [options]) - удаляет обработчик события handler (нужна та же фаза).
> event.preventDefault() - отменить действие браузера по умолчанию.
> event.defaultPrevented - если true, то событие по умолчанию отменено (лучше чем event.stopPropagation()).
> event.stopPropagation() - останавливает всплытие дальше.
> event.stopImmediatePropagation() - предотвращает всплытие включая текущий элемент.
> event.eventPhase - фаза, на которой сработал обработчик (погружение = 1, фаза target = 2, всплытие = 3).
> event.currentTarget === this - элемент, на котором в данный момент выполняется обработчик (меняется по мере всплытия).
> event.target - самый глубоко вложенный элемент, на котором сработал слушатель (не изменнен в процессе всплытия).
> event.buttons - возвращает номер кнопки мыши (0 - левая, 1 - средняя, 2 - правая и т.д.).
> event.clientX/clientY/pageX/pageY - | координаты курсора относительно окна/документа

>> События клавиатуры:
      > 'keydown' - срабатывает при нажатии клавиши
      > 'keyup'   - срабатывает при отпускании клавиши

>> Автоповтор - при долгом нажатии клавиши, событие 'keydown' срабатывает повторно, пока не сработает 'keyup'.
>> event.repeat === true - для событий вызванных автоповтором.

>> Клавиши-модификаторы: event.shiftKey - клавиша Shift         | - true, если нажаты во время срабатывания события
                         event.altKey   - клавиша Alt           |
                         event.ctrlKey  - клавиша Ctrl          |
                         event.metaKey  - клавиша Cmd для Mac   |

>> event.key - символ нажатой клавиши (буква, цифра, Enter, Tab, F1 и т.д.).
>> event.code - код нажатой клавиши (Key<буква>, Digit<цифра>, Enter, Tab, F1 и т.д.).

>> Делегирование событий - один обработчик на общего предка обрабатываемых элементов.
      Способы делегирования: 
            1. Простые проверки
            2. Атрибуты data- (этот способ называют "behavior" (поведение))

>> Создание пользовательских событий:
      1. new CustomEvent(type, options) - лучший способ для пользовательских событий
            > type - строка с названием события.
            > options === {
                  bubbles: true/false    - всплытие разрешить/запретить
                  cancelable: true/false - отмену события по умолчанию разрешить/запретить
                  composed: true/false   - всплытие за пределы Shadow DOM разрешить/запретить 
                  detail: { ... }        - объект для передачи любых пользовательских данных обработчику событий
            }

      2. new Event(type, options) - как CustomEvent, только без свойства detail в options.
      3. Конструкторы различных UI Event: UIEvent, FocusEvent, MouseEvent, WheelEvent, KeyboardEvent, ...

>> elem.dispatchEvent(event) - запускает объект-событие event на elem. 
                               Возвращает false, если какой-либо обработчик события вызвал event.preventDefault().

>> В событиях 'mouseover'/'mouseenter': event.target        - элемент, НА который курсор перешел.
                                        event.relatedTarget - элемент, С которого курсор ушел (может быть null).

>> В событиях 'mouseout'/'mouseleave': event.target - элемент, С которого курсор ушел.
                                       event.relatedTarget - элемент, НА который курсор перешел (может быть null).

>> В событиях 'mouseover'/'mouseout' курсор всегда над самым глубоко вложенным элементом.

>> События 'mouseenter'/'mouseleave' как 'mouseover'/'mouseout', но: 1. Не срабатывают на children;
                                                                     2. Не всплывают (невозвожно делегирование).
                                    
>> Событие 'scroll' срабатывает при прокрутке страницы.
                        
>> document.elementFromPoint(clientX, clientY) - возвращает наиболее глубоко вложенный элемент по заданным координатам.

>> Базовый алгоритм Drag'n'Drop:
      1. Подготовить к перемещению элемент :
            - mousedown
            - ondragstart return false
            - position absolute
            - z-index 1000
      2. Перемещать элемент:
            - mousemove
            - left top event.pageX evemt.pageY
      3. Если нужно, узнать, над каким элементом (droppable) в данный момент находится переносимый элемент (draggable)
            - elem.hidden true -> elemBelow document.elementFromPoint -> elem.hidden false
      4. Остановить перенос:
            - mouseup
            - removeEventListener mousemove mouseup

>> Свойства Pointer Events:
      1. Свойства, что и у Mouse Events.
      2. pointerId - id указателя, который вызвал событие (число генерируется движком).
      3. pointerType - тип указателя. Строковое значение: 'mouse'/'pen'/'touch'.
      4. isPrimary === true для основного (1-го) указателя, который вызвал событие.
      5. width/height - ширина/высота области соприкосновения указателя с устройством. === 1, если не поддерживается устройством.
      6. pressure - степень давления указателя в диапазоне от 0 до 1. === 0.5, если не поддерживается устройством.
      7. tangentialPressure - нормализованное тангенциальное давление.
      8. tiltX/tiltY/twist - положение пера относительно сенсорной поверхности.

>> События указателя (Pointer Events) аналогичны Mouse Events: 'pointer<событие>' аналог 'mouse<событие>'.
      
>> Событие указателя 'pointercancel' - срабатывает, когда действие с указателем прерывается 
                                       и события указателя больше не генерируются. 
                                       Причины срабатывания 'pointercancel':
                                          - выключение устройства
                                          - нажатие кнопки "Home"
                                          - смена ориентации устройства в пространстве
                                          - сработало событие по умолчанию
                                          - превышение максимально допустимого количества нажатий на экран
                                          - движок решил, что нажатие вызвано случайно
                                          
>> Событие 'gotpointercapture' - срабатывает при захвате указателя (setPointerCapture).
>> Событие 'lostpointercapture' - срабатывает при освобождении от захвата указателя (pointerup, pointercancel, releasePointerCapture).

>> { touch-action: none; } - CSS-свойство, чтобы предотвратить срабатывания события по умолчанию

>> elem.setPointerCapture(pointerId) - привязывает все дальнейшие Pointer Events с указанным pointerId к элементу.
                                       Захват указателя упрощает Drag'n'Drop.
                                       Освобождается от захвата при:
                                          1. Событии 'pointerup';
                                          2. Событии 'pointercancel';
                                          3. Удалении элемента из документа;
                                          4. Вызове elem.releasePointerCapture(pointerId).

+ Устаревшие события, методы и свойства
      event.which - возвращает номер кнопки мыши (0 - левая, 1 - средняя, 2 - правая и т.д.);
      event.keyCode - аналог event.key;
      'keypress' - срабатывает, когда нажимается клавиша создающая символ.


//////////////
18.  Cookie
//////////////

>> Cookie - строки данных, которые хранится в браузере. Являються частью HTTP протокола.

>> Алгоритм использования cookie при аутентификации:
      1. Пользователь посылает запрос на сайте;
      2. Сервер присылает браузеру HTTP-заголовок Set-Cookie, чтобы установить cookie с уникальным ID;
      3. При следующем запросе браузер посылает на сервер HTTP-заголовок Cookie;
      4. Сервер принимает cookie и определяет, кто сделал запрос.

>> document.cookie - возвращает строку с cookie - пары key=value разделенные ';'
                     Запись в document.cookie = "key=value" обновит cookie key, так как это getter/setter. 

>> Cookie options:
      1. path - абсолютный URL-префикс, для которого будут доступны cookie.
      2. domain - домен, которому доступны cookie. По умолчанию cookie доступны домену, который из установил.
                  Чтобы дать доступ поддоменам (forum.site.com) к cookie, необходимо явно задать параметр (domain=site.com).
      3. expires - дата истечения срока действия cookie. Формат: 'Tue, 19 Jan 2038 03:14:07 GMT'.
      4. max-age - срок действия cookie в секундах. При значении '<= 0' cookie удаляется.
      5. secure - ограничивает доступ к cookie только по HTTPS.
      6. samesite - ограничивает доступ к cookie исключительно доменом-владельцем. Надежная защита от XSRF.
            samesite=strict - cookie не отправляются при новом входе на сайт
            samesite=lax    - работает так же как и samesite=strict, но отправляет cookie если:
                                                      - используются безопасные HTTP-методы (например GET)
                                                      - осуществляется навигация на верхнем уровне
      7. httpOnly - запрещает доступ к cookie из JavaScript.
      8. Пример: document.cookie = 'key=value; path=/; max-age=3600; samesite=lax; httpOnly; secure'

>> date.toUTCString() - возвращает человеко-читаемую дату в виде строки (UTC).
>> encodeURIComponent(string) - кодирует компонент URI (Uniform Resource Identifier).
>> decodeURIComponent(encodedURI) - декодирует компонент URI, созданный с помощью encodeURIComponent.


//////////////////////////////////////
19.  LocaleStorage & SessionStorage
//////////////////////////////////////

>> localeStorage/sessionStorage - объекты web-хранилища, хранят пары СТРОК ключ-значение:
      - НЕ отправляются на сервер при каждом запросе
      - минимум 5 Мб памяти для данных
      - сервер не может их использовать
      - привязаны к источнику (домен/протокол/порт)

>> Методы:
      1. setItem(key, value)  - сохранить ключ-значение
      2. getItem(key)         - получить значение по ключу
      3. removeItem(key)      - удалить значение по ключу
      4. clear()              - удалить все данные из объекта хранилища
      5. key(index)           - получить ключ по индексу
      6. length               - количество элементов в объекте хранилища

>> Особенности localStorage:
      - 1 объект на 1 источник (все его вкладки)
      - данные не имеют срока давности
      - данные не удаляются при презапуске браузера или ОС

>> Особенности sessionStorage:
      - 1 объект на 1 вкладку и iframes из того же источника
      - данные не удаляются при перезагрузке вкладки

>>  Способы перебора ключей:
      1. Базовый цикл for () {}
      2. Object.keys(localeStorage)

>> Событие 'storage' - генерируется на всех вкладках (объекты window) источника кроме текущей.
                       Срабатывает при вызове setItem, removeItem, clear.
                       Свойства event: 
                              1. key         - ключ, который обновился (null при вызове .clear())
                              2. oldValue    - старое значение (null при первом добавлении ключа)
                              3. newValue    - новое значение (null при удалении ключа)
                              4. url         - url документа, где произошло обновление
                              5. storageArea - объект хранилища, где произошло обновление.


///////////////////////
20.  Сетевые запросы
///////////////////////

>> fetch(url, options) - делает сетевой завпрос на url с параметрами options. Без options делает простой GET-запрос.
      options: {
            method: "GET", // Метод запроса
            headers: { },  // Заголовки
            body: undefined, // Тело запроса типа: "String", "FormData", "Blob", "BufferSource", "URLSearchParams"
            referrer: "about:client", // Заголовок Referrer в пределах текущего источника (url или "")
            referrerPolicy: "strict-origin-when-cross-origin", // Устанавливает правила для Referrer (см. табл.)
            mode: "cors", // Режим запроса на другой источник
            credentials: "same-origin", // Указывает отправлять ли cookie и auth-headers вместе с запросом
            cache: "default", // Настройка HTTP-кеширования
            redirect: "follow", // Позволяет стандартный редирект
            integrity: "", // Позволяет проверить соответствует ли ответ известной заранее контрольной сумме
            keepalive: false, // Позволяет браузеру выполнить запрос после того, как пользователь покинул страницу (window.onunload)
            signal: undefined, // AbortController
            window: window
      }
     
>> fetch возвращает объект класса Response со свойствами и методами:
      - Свойства:
            1. status - код статуса HTTP-запроса
            2. ok - true если status в диапазоне 200-299, иначе false
            3. body - ответ как объект класса ReadableStream
      - Методы:
            1. text() - возвращает ответ как текст
            2. json() - возвращает ответ как JSON
            3. formData() - возвращает ответ как объект класса FormData
            4. blob() - возвращает ответ как объект класса Blob
            5. arrayBuffer() - возвращает ответ как объект класса ArrayBuffer 


>> FormData
> const formData = new FormData(form) - объект преобразованных данных HTML-формы в формат для отправки по сети.
                                         Данные отправляются всегда с заголовком 'Content-Type': 'multipart/form-data'.
> Методы formData:
      1. append(name, value) - добавить поле
      2. append(name, blob, fileName) - добавить поле с типа <input type='file'>
      3. set(name, value) - как append, но удаляет поля с таким же именем
      4. set(name, blob, fileName) - как append, но удаляет поля с таким же именем
      5. delete(name) - удалить поле с заданным именем
      6. get(name) - получить поле с заданным именем
      7. has(name) - проверить наличие поля с заданным именем

> const controller = new AbortController() - объект для прерывания любых асинхронных запросов.
> controller.abort() - генерирует событие 'abort' на объекте controller.signal, делает controller.signal.aborted === true.
> fetch(url, { signal: controller.signal }) - теперь fetch отслеживает событие 'abort'.


>> URL
> let url = new URL(url, [base]) - объект с мтеодами и свойствами для удобного разбора URL.
      (url - путь, если указа base, иначе полный URL)
      (base - базовый адрес, к которому прибавится путь url)
> url.searchParams - перебираемый объект типа SearchParams с методами, которые кодируют не-латинские символы:
      .append(name, value) - добавить параметр
      .delete(name) - удалить параметр
      .get(name) - получить параметр
      .getAll(name) - получить все параметры с одинаковым именем
      .has(name) - проверить наличие параметра
      .set(name, value) - заменяет значение параметра и удаляет все одноименные параметры
      .sort() - отсортировать по имени

> Методы кодирования/декодирования спец. символов в строках:
      1. encodeURI / decodeURI - кодирует/декодирует символы запрещенные в URI. Исп. для целого URI.
      2. encodeURIComponent / decodeURIComponent - кодирует/декодирует символы запрещенные в URI 
      и символы (#, $, &, +, ,, /, :, ;, =, ?, @). Исп. для какой-то части от URI.


>> XMLHttpRequest
> let xhr = new XMLHttpReques - объект, который позволяет делать HTTP-запросы к серверу без перезагрузки страницы.

> Методы xhr: 
      .open(method, url, [async, user, password]) - конфигурирует запрос.
            (async - если указать false, то запрос будет синхронным (исп. редко))
            (user, password - логин и пароль для базовой HTTP-авторизации)
      .send([body]) - посылает запрос
      .abort() - отменяет запрос, генерирует событие 'abort', устанавливает xhr.status = 0
      .setRequestHeader(name, value) - устанавливает заголовок запроса. !!! Отменить невозможно. Повторные вызовы добавляют информацию
      .getResponseHeader(name) - возвращает значение заголовка ответа (кроме Set-Cookie и Set-Cookie2)
      .getAllResponseHeaders() - возвращает все заголовки ответа (кроме Set-Cookie и Set-Cookie2)

> Синхронный запрос - запрос, когда выполнение JS останавилвается на xhr.send() и возобновляется после получения ответа (исп. редко).

> События для получения ответа:
      1. load - когда получен какой-либо ответ, включая ответы с HTTP-ошибкой (404)
      2. error - когда запрос не может быть выполнен (невалидный URL)
      3. progress - периодически во время загрузки ответа от сервера, сообщает о прогрессе (event.loaded, event.total)
      4. timeout -  когда вышло время отведённое на загрузку
      5. abort - когда запрос прерван

> Свойства xhr:
      1. status - код состояния HTTP (200)
      2. statusText - сообщение о состоянии HTTP-ответа
      3. response - тело ответа
      4. timeout - время, которое мы готовы ждать ответ (в миллисекундах)
      5. responseType - указывает ожидаемый тип ответа: 'text', 'json', 'arraybuffer', 'blob', 'document'
      6. readyState - код состояния запроса: 0 - unsent, 1 - opened, 2 - header received, 3 - loading, 4 - done
      7. upload - объект, который генерирует события для отслеживания отправки данных на сервер:
            loadstart, progress, abort, error, load, timeout, loadend (все аналогичны событиям xhr)
      8. withCredentials - если установить в true, то при запросе на другой источник (origin) отправлять также cookie и auth-headers

>> Способы поддерживать постоянное соединение с сервером:
      1. Частые опросы - регулярный запрос (например раз в 10 секунд)
      2. Длинные опросы - запрос > ответ сервера только когда есть сообщения > незамедлительно новый запрос
      3. WebSocket
      4. EventSource


>> WebSocket - протокол, предоставляющий возможность обмениваться данными между браузером и сервером через постоянное соединение,
               то есть без разрыва соединения и дополнительных HTTP-запросов.

> let socket = new WebSocket('wss://example.info') - установить соединение, отправить заголовки.
> socket.send(data) - отправить текстовые или бинарные данные(Blob, ArrayBuffer).
> socket.binaryType - формат бинарных данных (по умолчанию Blob).
> socket.bufferAmount - количество буферизированных данных ожидающих отправки по сети (очередь).
> socket.close([code], [reason]) - закрыть подключение [с кодом и причиной].
> socket.readyState - код состояния соединения: 0 - подключение
                                                1 - подключено (обмен данными)
                                                2 - закрытие соединения
                                                3 - соединение закрыто                        
> События socket: open, message, error, close.
> Браузер отправляет спец. заголовки на сервер, чтобы проверить поддерживает ли он WebSocket. Положительный ответ 101.
> Передача данных делится на фрагменты (frames).

>> EventSource
> let eventSource = new EventSource(url, [{ withCredentials: true }]) - создаёт постоянное соединение с сервером и слушает его события (Server Sent Events).
> eventSource.lastEventId - id последнего обработанного события 'message'.
> eventSource.readyState - код состояния соединения: 0 - подключение или переподключение
                                                     1 - подключено
                                                     2 - подключение закрыто
> Свойства:
      - данные посылает только сервер
      - только строчный тип данных (чаще всего исп. JSON)
      - протокол соединения HTTP
      - при обрыве соединения автоматически переподключается

> Типы событий: 'message', 'open', 'error', кастомные события.

> Принцип работы сервера:
      1. Сервер передаёт строку с обязательным полем data и необязательными полями id, event, retry
      2. Поля разделяются через \n
      3. Поле id - записывается в eventSource.lastEventId и при переподключении браузер отправляет заголовок Last-Event-ID
      со значением id на сервер для возобновления передачи данных начиная с сообщения с таким id
      4. Поле event - кастомное событие
      5. Поле retry - время в миллисекундах, спустя которое будет попытка переподключения к серверу

> Пример передаваемой строки в NodeJS: res.write('retry: 15000\nevent: customEvent\ndata: someData\nid: 1\n\n')


///////////////////////
21.  iframe и window
///////////////////////

>> window.open(url, name, parans) - открывает окно pop-up (новый window), возвращает ссылку на это окно.
                                    window.opener - ссылка на открывающее его окно.

>> window.postMessage(data, target) - отправляет data в target, вызывает событие 'message' в target.

>> Критерии одинакового источника (полного доступа):
      - протокол
      - домен
      - порт

-----------------------------------
* * * Библиотеки и Фреймворки * * *
-----------------------------------

////////////
1.   Jest  
////////////

Jest - фреймворк для тестирования JavaScript. Работает с ReactJS, NodeJS, Babel, TypeScript, Vue, Angular.

>> Цель автотестирования - проверка соответствия ПО предъявляемым требованиям.

>> Регрессионное тестирование - проверка целосности старого ПО, после внесения новых изменений.

>> Функциональное тестирование:
      > UNIT (модельное) - тест на отдельну независимую фу-ю, компонент.
      > Скриншотные тесты - сравнение старой и новой визуальной части (UI).
      > INTEGRATION (интеграционные) - взаимодействие нескольких фу-й или компонентов.
      > E2E (end-to-end) - полная функциональность частей приложения (регистрация, авторизация, оплата).

>> Expect-методы - сопоставляют фактический результат от ожидаемого.

>> Mock - тестовый двойник, то есть тестовые значения, которые заменяют производственный код во время выполнения тестов.

>> Mock-функции:
      - перехватывают вызовы
      - устанавливают возращаемое значение
      - изменяют реализацию

>> mockFn.mockReturnValue(value) - возвращает value при каждом вызове mockFn
>> jest.mock(module) - автоматически устанавливает все экспорты module в mock-функцию.
      Например: 
            jest.mock('./foobar.js') эквивалент след. записям:
                  ~ export const foo = jest.fn()
                  ~ export const bar = jest.fn() и т.д.


//////////////
2.   Node
//////////////

>> Команды npm:
    > npm -h (--help)               // вызов справки
    > npm i  (install)              // устанавливает зависимости для проекта
    > npm i -D (install --save-dev) // устанавливает зависимости для разработки
    > npm t  (test)                 // запуск тестирование
    > npm -g (--global)             // флаг глобальной установки
    > npm init -y (--yes)           // принятие установок инициализации
    > npm init -f (--force)         // принятие установок инициализации
    > npm -O (--save-optional)      // сохранение пакета в виде опциональной зависимости
    > npm -E (--save-exact)         // сохранение сведений о точной версии пакета
    > npm -B (--save-bundle)        // записывает в package.json в bundleDependencies список установленных пакетов
    > npm pack                      // создает tarball-файл, содержащий файлы проекта и пакеты из bundleDependencies

>> Node.js - среда выполнения кода JavaScript:
    - на основе JS Chrome V8
    - позволяет выполнять JS вне веб-браузера
    - предназначен для создания серверных приложений
    - хорошо подходит для обработки потоковых данных в реальном времени
    - НЕ подходит для решения задач, требующих много ресурсов

>> Особенности Node.js:
    1. global
    2. Нет взаимодействия с DOM
    3. Есть доступ к файловой системе клиента       

>> Node REPL - интерактивный интерпретатор (Read-Evaluate-Print-Loop)

>> Встроенные модули Node.js:
    - path
    - http
    - js (можно работать через Promise)
    - os
    - crypto
    
>> runtime - означает запущенный процесс в ОЗУ, который откликается на команды

>> LibUV - библиотека на C++, которая обеспечивает поддержку неблокирующих операций ввода-вывода
>> C++ Bindings - термин выделяющий группу библиотек (посредники), которые позволяют использовать в Node.js функционал библиотеки LibUV
>> Thread Scheduler (Планировщик потоков) - часть ОС, которая отвечает за паралельное выполнение задач

>> worker_threads - модуль в Node.js позволяющий управлять потоками из кода

>> Демультиплексор событий - собирает и ставит в очередь события I/O

>> Принцип работы шаблона REACTOR:
    Приложение[I/O <--> Обработка] --> Демультиплексор событий --> Очередь событий --> Event Loop <--> Приложение

>> Processes and threads (процессы и потоки):
    1. Node.js имеет  1 поток, который обрабатывает все запросы
    2. LibUV обеспечивает поддержку многопоточных операций (ассинхронные неблокирующие операции)

>> LibUV: 1. Event loop - асинхронно обрабатывает событийные операции (вызываются фу-и подписанные на события)
          2. Thread pool - асинхронно обрабатывает операции из основного потока кода:
              - по умолчанию 4 threads
              - максимум 1024 threads

>> Этапы выполнения событий в Event loop:
    1. process.nextTick ( метод, который вызывает любой callback немедленно, независимо от этапа event loop )
    2. Promise
    3. Timers ( setTimeout, setInterval )
    4. Pending ( Input/Output callbacks отложенные до след. итерации event loop)
    5. Idle, Prepare ( внутренние служебные задачи Node.js )
    6. Poll ( event loop получает и выполняет задачи Input/Output )
    7. Check ( setImmediate )
    8. Close ( close event callbacks )
    9. Продолжать ли event loop? ( если нет, то выход из цикла )

>> Этапы выполнения событий в Event loop (Упрощенная схема):
    1. process.nextTick <---┐
    2. Promise              |
    3. Timers               |
    4. I/O Events           |  
    5. Check                |
    6. Close ---------------┴---> Выход из Event loop  
    
>> Способы экспорта сущностей:
    1. module.exports.foo = foo
    2. module.exports.foo = function () {}
    3. module.exports = function () {}      // экспорт по умолчанию

>> Внутреннее устройство модуля в Node.js (common.js):
    (function (exports, require, module, __filename, __dirname) {
        console.log(arguments.callee.toString())
    })

>> Streams (потоки):
    - Readable
    - Writable
    - Duplex (Readable + Writable)
    - Transform (как Duplex, но может изменять данные по мере чтения)


////////////
3.   Vite
////////////

Vite - инструмент сборки web-приложений.

>> Основные части:
    1. Dependencies (зависимости) - в основном native JS, редко изменяется.
    2. Source code (исходный код) - постоянно редактируемый код.

>> Основные инструменты:
    1. Dev-сервер
    2. Build-команды


/////////////
4.   React
/////////////

>> React - JS-библиотека для построения интерактивного UI.

>> React Native - фреймворк для разработки Android и IOS приложений.

>> Этапы отрисовки компонента:
    1. Триггер render
      - начальный render (createRoot --> root.render)
      - re-render (обновление состояния)
    2. render
    3. Фиксация в DOM

>> События-пропсы с окончанием 'Capture' (например onClickCapture) обрабатываются на этапе погружения раньше остальных.  

>> Reconciliation (согласование, урегулирование, сверка) - механизм сравнения деревьев. Правила сравнения:
    - элементы сравниваются последовательно (сверху вниз)
    - при смене типа (тега) элемента он перемонтируется
    - при указанном key элемент перемонтируется только при смене типа (предыдущее правило)

*           useState

>> Свойства useState(initValue):
    1. render только после изменения состояния (изменение примитива или ссылки)
    2. Фу-я изменения состояния (set) работает асинхронно 
    3. При useState(callback) в callback передается как аргумент предыдущее состояние
    4. Возможность передавать фу-ю возвращающую initValue. 
       С целью оптимизации лучше всего передавать callback, вызов которого вернет результат вызова фу-и,
       чтобы рендерить только после внесения всех состояний в фу-и.

>> Состояние можно обновлять любое количество раз, но оно не изменится до след. рендера:
    - setValue(value)    --> заменить состояние
    - setValue(callback) --> добавить callback в очередь на render
                             callback принимает текущее состояние и возвращает следуюющее.

>> Изменение состояния объектов и массивов:
      - устанавливать копию с нужными изменениями (..., map, filter, concat, slice)
      - вложенные объекты и массивы также необходимо копировать
      - лучше всего использовать библиотеку Immer  

>> key - уникальный только в родительской ОВ, глобальная ОВ доступа к нему не имеет.

>> Способы сбросить состояния компонента до начального значения:
    1. Удалить, затем добавить компонент.
!!!    Наиболее распостранненным решением является "поднятие состояния" в родительский компонент,
       чтобы сохранить состояния независимо от наличия компонента в DOM-дереве.
    2. Передать key. При каждом изменении key React ре-рендерит один и тот же компонент, 
       но состояния соответсвуют своему key.
!!!    Состояния необходимо сохранять вне компонента, например в localStorage.

*           useReducer

>> const [state, dispatch] = useReducer(reducer, initArg, init):
      -> state - текущее состояние
            --> после 1-го рендера state === initArg или === init(initArg) 
      -> dispatch - фу-я, вызов которой позволяет обновить state и вызвать ре-рендер
            --> принимает 1 аругумент - action (обычно объект со свойством type)
            --> action добавляется в очередь
            --> ре-рендера не будет, если Object.is( currentState, nextState ) === true
            --> ре-рендер будет только после срабатывания ВСЕХ обработчиков dispatch вызванного события
      -> reducer - фу-я, в которой обновляется state
            --> принимает 2 аргумента: (state, action)
            --> возварщает следующий state
      -> initArg - начальное значение state, или значение, на основе которого оно вычисляется в фу-и init
      -> init - опциональная фу-я, которая возвращает начальное state вычисленное на основе initArg

>> useReducer добавляет action в очередь

*           useContext

>> createContext и useContext служат для передачи данных от родительского элемента к глубоко вложенным дочерним элементам,
   минуя при этом элементы, которые не используют передаваемые данные.

>> createContext(defaultValue):
    1. Возвращает компонент-контекст
    2. defaultValue нельзя изменить. useContext возвращает это значение в одном случае: нет провайдера-родителя выше по иерархии
    3. Пропс value компонента NameContext.Provider передает любое значение дочерним компонентам, 
       которые используют useContext(NameContext)
    4. Многоразовым вызовом NameContext.Provider можно перезаписывать значение value

>> useContext(NameContext):
    1. Возвращает значение, котороле было передано в пропс value компонента NameContext.Provider,
       или defaultValue, если не найден такой компонент выше по иерархии
    2. NameContext.Provider должен быть родительским компонентом по отношению к компонентам, которые будут использовать useContext

>> Рекомендации по использованию useContext:
    1. Переписать приложение с использованием useContext, когда количество передаваемых пропсов приближается к 10.
    2. Создавать отдельный файл, из которого будут экспортироваться useContext's.
    3. Комбинировать useContext и useReducer в одном файле:
        3.1. createContext
        3.2. export NameProvider > useReducer > return Providers chain > children
        3.3. declare nameReducer
        3.4. export custom hooks (return useContext)

*           useRef

>> useRef используется для: 
      - хранения данных не зависящих от рендера
      - получения доступа к DOM-элементам

>> useRef(initValue) - возвращает объект со свойством current.
                       Вызывается только один раз - во время инициализирующего рендера компонента.

>> Обычно initValue устанавливают в null, затем изменяют current, так как current === initValue на каждом,
   рендере пока current не будет изменено.

>> Свойство current: 
      - можно менять
      - при изменении не вызывает ре-рендер
      - записывать и читать нужно в useEffect и обработчиках событий, а не во время рендера
      - при передаче объекта в атрибут ref JSX-элемента, свойство current будет содержать ссылку на этот элемент

*           useEffect

>> useEffect(setup, dependencies) - позволяет синхронизировать компонент с внешними системами.
      -> setup - callback, который вызывается при срабатывании эффекта.
            --> может вернуть cleanup-callback, который выполнит очистку.
            --> при ре-рендере компонента вызывает cleanup со старыми значениями, затем setup с новыми
            --> при удалении компонента из DOM вызывает cleanup 
      -> dependencies - опциональный массив значений:
            --> при его отсутствии - эффект срабатывает при каждом рендере компонента
            --> при пустом массиве [] - эффект срабатывает единожды: при инициализирующем рендере
            --> при наличии значений в массиве - эффект срабатывает после каждого изменения какого-либо из значений
                               

////////////
5.   Next
////////////

>> Next.js - фреймворк React для создания клиентских приложений с участием серверного рендеринга. 

>> Способы навигации:
      - Link (рекомендованный)
      - useRouter (клиентские компоненты)
      - redirect (серверные компоненты)
      - History API

>> Стратегии рендеринга:
    - Client Side Rendering (CSR)
    - Static Site Generation (SSG)
    - Server Sider Rendering (SSR)
    - Incremental Static Regeneration (ISR)

!!! По умолчанию Next использует SSG.

>> CSR - стратегия рендеринга, когда вся работа выполняется на стороне клинета (в браузере).

>> Принцип работы CSR: 
    1. Запрос на сервер (открытие сайта)
    2. Загрузка index.html содержащий <div id="root"> и <script> (React-приложение)
    3. Загрузка <script> 
    4. ReactDOM встраивает React-приложение в <div id="root">
    5. API-запрос данных
    6. Отображение данных на странице
    
>> SSG - стратегия рендеринга, когда когда сервер отправляет на клиент (в браузер) готовую статическую страницу, 
            при этом API-запросы выполняются во время сборки приложения (build).

>> SSR - стратегия рендеринга, когда сервер отправляет на клиент (в браузер) готовую интерактивную страницу.

>> Этапы SSR:
    1. Запрос данных у сервера (при первом входе пользователя на сайт)
    2. Рендеринг HTML на сервере
      - React преобразует Server Components в спец.формат данных RSC Payload, ссылающийся на Client Components
      - Next использует инструкции JS в RSC Payload и Client Components, чтобы отрисовать HTML на сервере в соответствии с указанным роутом
    3. Отправка HTML, CSS, JS клиенту
    4. Отображение НЕинтерактивного UI (HTML, CSS)
      - отображение неинтерактивного HTML по указанному роуту
      - используя RSC Payload, Next сверяет клиентские и серверные деревья, обновляет DOM
    5. Гидратация UI (встраивание интерактивности на страницу)
    6. При переходе между страницами работает CSR

>> ISR - стратегия рендеринга, когда статически сгенерированные сервером страницы (SSG) ререндерятся по триггеру (например событие).

>> React Server Component Payload (RSC) - бинарное представление React Server Components. 
      Используется для обновления браузерного DOM.
      Содержит:
      - преобразованный результат Server Components
      - placeholders для Client Components и ссылки на их JS
      - пропсы передаваемые из Server Components в Client Components

>> Hydration - процесс подключения обработчиков событий к DOM, чтобы сделать статический HTML интерактивным.

>> Streaming - процесс разделения HTML на небольшие части (chunks), например React-компоненты, и отправки их клиенту по отдельности.

>> Иерархия рендеринга спец.компонентов: layout -> template -> error -> loading -> not-found -> page

>> Отличие template от layout в том, что template создает новый экземпляр шаблона для каждого дочернег элемента, 
      соответственно сбрасываются состояния и эффекты.


-----------------------
* * * Базы данных * * *   
-----------------------

///////////
1.   SQL
///////////


//////////////////
2.   PostgreSQL
//////////////////


-------------------------
* * * Полезный софт * * *   
-------------------------

>> randomUUID() - возвращает строку типа v4 UUID (Universally Unique Identifier) из 36 случайных символов, 
                  используя криптографически безопасный генератор случайных чисел.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
1.   Cache-Wrapper + call + apply 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

let workers = {
   someProp: 10,
    
   someMethod(arg1, arg2) {
   return arg1 + arg2 + this.someProp
   },
}

workers.someMethod = cachingDecorator(workers.someMethod, hash)
    
function hash() {
   return [].join.call(arguments)
}
    
function cachingDecorator(func, hash) {
   let cache = new Map()
    
   return function (...args) {
      let key = hash(arguments)
   
      if (cache.has(key)) return cache.get(key)
    
      let result = func.apply(this, args)
    
      cache.set(key, result)
    
      return result
   }
}

console.log(workers.someMethod(1, 2))


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
2.   Object.prototype.toString - расширенный typeof
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

let objToString = Object.prototype.toString

let user           = { [Symbol.toStringTag]: 'User' }       
let array          = []                                     
let number         = 123                                    
let string         = 'str'                                  
let boolean        = true                                   
let nullValue      = null                                   
let functionValue  = alert                                  
let undefinedValue = undefined                              

objToString.call(user)              // [object User]    
objToString.call(array)             // [object Array]
objToString.call(number)            // [object Number]
objToString.call(string)            // [object String]
objToString.call(boolean)           // [object Boolean]
objToString.call(nullValue)         // [object Null]
objToString.call(functionValue)     // [object Function]
objToString.call(undefinedValue)    // [object Undefined]


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
3.   Обёртывание исключений
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

class ReadError extends Error {
      constructor(message, cause) {
        super(message)
        this.cause = cause
        this.name = 'ReadError'
      }
}
    
class ValidationError extends Error {
      constructor(message) {
            super(message)
            this.name = this.constructor.name
      }
}
    
class PropertyRequiredError extends ValidationError {
      constructor(property) {
            super('Absent property: ' + property)
            this.property = property
      }
}
    
function readUser(json) {
      let user
    
      try {
            user = JSON.parse(json)
      } catch (error) {
            if (error instanceof SyntaxError) throw new ReadError(error.name, error)
            else throw error
      }
    
      try {
            validateUser(user)
      } catch (error) {
            if (error instanceof ValidationError) throw new ReadError(error.name, error)
            else throw error
      }
}
    
function validateUser(user) {
      if (!user.age) throw new PropertyRequiredError('age')
      if (!user.name) throw new PropertyRequiredError('name')
    
      return user
}
    
try {
      readUser('{ "name": "k", "age": 25 }')
} catch (error) {
      if (error instanceof ReadError) {
            console.log(`${error.name}: ${error.cause}`)
      } else throw error
}


\\\\\\\\\\\\\\\\\\\\\\
4.   Промисификация   
\\\\\\\\\\\\\\\\\\\\\\

function promisify(fn, manyArgs = false) {
      return function (...args) {
            return new Promise((resolve, reject) => {
                  function callback(error, ...results) {
                        if (error) reject(error)
                        else resolve(manyArgs ? results : results[0])
                  }
    
                  args.push(callback)
    
                  fn.call(this, ...args)
            })
      }
}
    
fn = promisify(fn, true)
fn(...).then(arrayOfResults => {...}, error => {...})


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
5.   Функции для работы с cookie
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

// Получить cookie
function getCookie(name) {
      let matches = document.cookie.match(new RegExp(
            '(?:^|; )' + name.replace(/([\.&?*|{}\(\)\[\]\\\/+^])/g, '\\$1') + '=([^;]*)'
      ))

      return matches ? decodeURIComponent(matches[1]) : undefined
}

// Установить cookie
function setCookie(name, value, options) {
      let updatedCookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`

      if (options.expires instanceof Date) options.expires = options.expires.toUTCString()

      for (let optionKey in options) {
            let optionValue = options[optionKey]

            updatedCookie += `; ${optionKey}`
            
            if (optionValue !== true) updatedCookie += `= ${optionValue}`
      }

      document.cookie = updatedCookie
}

// Удаление cookie
function deleteCookie(name) {
      setCookie(name, '', { max-age: -1 })
}


\\\\\\\\\\\\\\\\\\\\\\
6.   Длинные опросы
\\\\\\\\\\\\\\\\\\\\\\

!!! Сервер должен поддерживать много ожидающих соединений

async function subscribe() {
      let response = await fetch(url)

      if (response.status === 200) {
            let message = await response.text()
            showMessage(message)
            await subscribe()
      } else if (response.status === 502) await subscribe()
      
      else {
            showMessage(response.statusText)
            await new Promise(resolve => setTimeout(resolve, 1000))
            await subscribe()
      }
}