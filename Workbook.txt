* JavaScript

> Object.is(NaN, NaN)   // true
> Object.is(0, -0)      // false
> NaN === NaN           // false
> null == undefined     // true   // Равны друг другу и не равны любому другому значению
> null > 0              // false  
> null == 0             // false  
> null >= 0             // true   
> undefined > 0         // false  // undefined преобразуется в NaN
> 'some' > 'string'     // false  // Строки сравниваются посимвольно
> 
> 1 / 3                 // 0.3333333333333333
> 10 / 3                // 3.3333333333333335 (округляет до ближайшего возможного согласно формату IEEE 754)
> NaN ** 0              // 1
> 1 / 0                 // Infinity
> 1 / 4                 // 0.25
> "str" / 2             // NaN (При любых математических операциях со строками вернет NaN, кроме +)
> 1 + NaN               // NaN
> 1 + '2'               // '12'
> '2' - 1               // 1
> true + false          // 1
> true + true           // 2
> undefined + undefined // NaN
> null + null           // 0
> NaN + NaN             // NaN
> [] + []               // ''
> 
> typeof(Math)          // 'object' 
> typeof(Object)        // 'function'
> typeof(null)          // 'object'
> typeof(undefined)     // 'undefined'
> typeof(alert)         // 'function'
> 
> String(true)          // "true"
> String(null)          // "null"
> String(undefined)     // "undefined"
> 
> Number(undefined)     // NaN
> Number(null)          // 0
> 
> Boolean('0')          // true
> Boolean(' ')          // true
> Boolean('')           // false
> Boolean(NaN)          // false
> Boolean(null)         // false
> Boolean(undefined)    // false
> 
> a ^ b ^ b === a
> ~n === -(n + 1)
> a << n === a * 2**b
> a >> n === a / 2**b (крайний-левый бит (знак числа) не меняется)

#* Математическая фу-я
    = это описание некой строгой зависимости величин
    - Процессор является реализацией мат. фу-и

#* Фу-я, метод, оператор, инструкция, программа, процедура, команда
    = все эти слова означают одно и тоже - мат. фу-я, которая описана на языке программирования
    - При запуске, программа будет физически реализована

#* Стандарт (Спецификация)
    = задокументированный способ написания программ

>> Библиотека - дополнительные фу-и.
>> Фреймворк - настраивает и обеспечивает дополнительную структуру и возможности, оптимизирует приложение,
      предоставляя задокументированный способ решать задачи в условиях существующих ограничений.

>> Полифил - аналог метода в спецификации, который не поддерживается в более старой версией движка.
>> Инкапсуляция - разделение интерфейса на внутренний и внешний (приватный и публичный).
>> Область видимости - правила описывающие доступность переменных в разных частях кода. Типы ОВ в JS:
      1. Глобальная
      2. Функциональная 
      3. Блочная 
>> "Контекст выполнения", "Лексическое окружение", "Область видимости": - эти термины описывают:
      1. Где и как будут храниться переменные
      2. Где они будут доступны для использования
>> Мемоизация - создание фу-и для сохранения ранее вычисленного результата (кеш).
>> Кэш (cache) - хранилище браузера для временного хранения копий файлов с сайтов,
      чтобы ускорить их загрузку при повторном использовани.   
>> Микросервисная архитектура - схема построения ПО, при котором приложение разбивается на множество небольших,
      слабосвязанных между собой сервисов.
>> runtime - означает запущенный процесс в ОЗУ, который откликается на команды

>>  Для хранения Number выделяется 64 бита: 52 - для чисел, 11 - для положения десятичной точки, 1 - для знака.
>>  Область видимости `var` ограничивается функцией.
>>  if (false) var phrase - переменная phrase создасться, поскольку объявления var всплывают в начало фу-и.
>>  == и Boolean() используют разные правила приведения типов.

#* Компилятор
	= преобразует исходный код в машинный код и записывает в 1 исполняемый файл
	- Типы компиляторов (по моменту компиляции):
		#- AOT (Ahead Of Time)
			#/ Компилирует код целиком до выполнения программы
		#- JIT (Just In Time)
			#/ Компилирует код частями (line) во время выполнения программы

#* Event Loop
	= механизм, реализующий асинхронное выполненение JS-кода
	- Не является частью движков, он предоставляется средой (браузер, node), а его реализация может отличаться.
	- Приоритетность выполнения кода:
    	1. Call Stack (часть движка)
    	2. Web API (часть браузера)
    	    #- timers, после истечения времени передаётся в Macrotask
    	    #- handlers, пока не будут явно удалены (removeEventListener)
    	3. Task Queue (часть Event Loop)
			#! Сначала все microtasks, затем 1 macrotask
    		3.1. Microtask
    	        #- Promise
    	        #- queueMicrotask
    	        #- mutationObserver
    	    3.2. Macrotask
				#- timers 
				#- events

#* Задачи, которые решает JS Interpreter 
	# V8, SpiderMonkey
    - работа с Heap (куча) и Call Stack (стек вызовов)
    - работа с памятью (выделение памяти, сбор мусора)
    - компиляция JS в машинный код
    - оптимизация (кеш)


##############################################
*		Инструкции по написанию метода        
##############################################

#* 1. Написать подробный тест на метод
#* 2. Описать принцип, при помощи которого метод решает задачу
#* 3. Написать тело метода

#* SOLID
	= правила построения структуры проекта и написания кода:
	- S-ingle responsibility 
		#- единственная ответственность сущностей, то есть 1 сущность решает 1 задачу
    - O-pen-closed
		#- Добавление новых сущностей вместо изменения старых
    - L-iskov substitution (подстановка им. Лискова)
		#- Дочерняя сущность должна дополнять родительскую, а не изменять
    - I-nterface segregation
		#- Сущность не должна иметь зависимость от свойств и методов, которые она не исп.
    - D-ependency inversion
		#- Высокоуровневый модуль не должен зависеть от низкоуровневого модуля
        #- Они оба должны зависеть от абстрактного класса, то есть от прослойки между этими модулями


#################################################
* 		Инструкция по созданию приложения
#################################################

#* Описать проект
    - Основные цели
    - Содержание (cтраницы, функционал, зависимости)

#* Определить
	- Технологии
	- Архитектуру
    - Алгоритм действий в задачах:
		#- Сортировка
    - Стиль кода:
		#- Именования
	- Создание своих библиотек/утилит

#* Схематически изобразить дизайн приложения
#* Нарисовать макет
#* Определить проектируемые сущности (таблицы)
#* Определить колонки таблиц
#* Определить типы колонок
#* Определить индексы таблиц
#* Определить ограничения доступа к таблицам 

#* Организовать команду:
	- ??? Правила
	- ??? Дисциплина

#* Составить план
	- График
	- Иерархия задач

#* Реальзовать сервер
#* Реализовать БД
#* Реализовать статичное приложение
#* Реализовать логику в Fron-End

#! По достижении существенного результата или прошествии времени оценить и описать скорость выполнения задач


#################################
* 		Состав приложения
#################################

#* User Interface 
    - как пользователь будет взаимодействовать с приложением
#* Routing 
    - как пользователь будет перемещаться между разными частями приложения
#* Data Fetching 
    - где хранить данные и как их получить
#* Rendering 
    - когда и где рендерить статический и динамический контент
#* Integrations 
    - какие сторонние сервисы использовать и как к ним подключаться (CMS, auth, payments)
#* Infrastructure
    - где выкладывать, хранить и запускать приложение
#* Performance
    - как оптимизировать приложение для конечного пользователя
#* Scalability
    - до какой степени приложение будет масштабируемым (ко-во пользователей и кода)
#* Developer Experience


#####################################
* 		Критерии к стилю кода
#####################################
	
	- При одинаковых по смыслу переменных называть их целыми словами, которые описывают их отношение
	- В объявлении фу-и указывать тип параметров и тип возвращеаемого значения, а не тип самой фу-и


#####################
* 		Атаки
#####################

#* clickjacking
    = клик вредоносной страницей на сайте-жертве
    - Принцип: 
        #/ На вредоносной странице размещается прозрачный <iframe src="сайт-жертва.com">.
        #/ При попытке кликнуть по желаемому элементу пользователь на самом деле кликнет по iframe.
    - Защита:
        #- HTTP-заголовок X-Frame-Option: SAMEORIGIN
        #- Перекрывающий div
#* XSS (Cross-Site Scripting)
    = внедрение вредоносного кода, который выполняется в браузере жертвы
    - Виды:
        #- Reflected
            # Принцип:
                1. Скрипт передается через URL-параметры, HTTP-заголовки, формы
                2. Сервер возвращает скрипт как часть ответа
                3. Браузер жертвы выполняет скрипт
        #- Stored
            # Принцип:
                1. Скрипт отправляется на сервер, где сохраняется в БД
                2. Когда сервер возвращает запись из БД другим пользователям
                3. Их браузер выполняет скрипт
        #- DOM-based
            # Принцип:
                > Скрипт записывается в DOM-дерево и выполняется браузером
    - Защита:
        #- Фильтрация и валидация данных на клиенте и сервере
        #- Исп. правила Content Security Policy

#* CSRF (Cross-Site Request Forgery)
    = какие-либо действия на сайте от имени жертвы, где она авторизована
    - Принцып:
        1. Авторизованная жертва открывает ловушку (картинка, ссылка)
        2. Конфиденциальные данные отправляются на сервер автоматически
        3. Сервер не отличает легальный запрос от CSRF и выполняет действия
    - Защита:
        #- CSRF-токен
            # Не нужен, если исп. JWT + SameSite:Strict
			# При запросе клиент отправляет в теле запроса или в заголовке X-CSRF-Token
        #- Правильная настройка CORS
        #- Cookie с атрибутом SameSite

#* Brute Force
    = подбор пароля путём перебора комбинаций
    - Принципы: загугли
    - Защита:
        #- Ограничение попыток входа для однго IP или аккаунта
        #- Капча

#* MITM (Man In The Middle)
  	= перехват данных, которыми обмениваются клиент-сервер
  	- Защита:
    	#- Исп. HTTPS (TSL)


////////////////////////////
1.   Основные типы данных   
////////////////////////////

      1. Number (спец. числовые значения: Infinity, -Infinity, NaN)                     
      2. BigInt (для работы с целыми числами произвольной длинны)
      3. String
      4. Boolean
      5. Null
      6. Undefined
      7. Symbol
      8. Object

>> Виды записей переменных:
      1. PascalCase - типы и классы
      2. BIG_SNAKE_CASE - константные значения
      2. camelCase - все остальное

>> Унарный ' + ' не работает с BigInt числами
>> Ṩ === 'S\u0307\u0323' (Ṩ === S + точка сверху + точка снизу)
>> NaN - можно получить в результате выполнения числовой фу-и над нечисловыми значениями.

>> 0b11111111 - двоичная форма числа 255.
>> 0o377 - восьмеричная форма числа 255.
>> 0xff - шестнадцатеричная форма числа 255.


////////////////////////////
2.   Преобразование типов   
////////////////////////////

      1.  Строковое (String(value))
      2.  Числовое (Number(value), '6' / '2' = 3)
      3.  Логическое (Boolean(value))

>> Array.isArray(value) - проверяет является ли value массивом.


/////////////////
3.   Операторы   
/////////////////

- унарные
- бинарные
- сравнения
- логические

++value   > возвращает новое значение

value++   > возвращает старое значение

==        > преобразует операнды к числу

===       > проверяет равенство без приведения типов

||        > возвращает первое истинное значение, либо последнее значение при всех false

||=       > Логическое присваивание ИЛИ - если операнд слева falsy, то ему присваивается операнд справа

&&        > возвращает первое ложное значение, либо последнее значение при всех true

&&=       > Логическое присваивание И - если операнд слева truthy, то ему присваивается операнд справа

??        > Оператор нулевого слияния (Nullish coalescing operator):
            - возвращает первый аргумент, если он не null/undefined
            - запрещено использовать с && и ||
            - result = a ?? b - эквивалент записи - result = (a !== null && a !== undefined) ? a : b

??=       > Оператор нулевого присваивания - если операнд слева undefined/null, то ему присваивается операнд справа

?.        > Оператор опциональной последовательности (optional chaining):
            - работает только с объявленными
            - работает только для чтения и удаления
            - немендленно возвращает undefined, если левая часть null/undefined
            - obj.foo?.() - для фу-и
            - obj?.[key] и obj?.key - для свойства

>> Побитовые операторы работают с 32-битными целыми со знаком, старшим битом слева и дополнением до двойки:
      - страший бит слева - от большего разряда к меньшему
      - дополнение до двойки - в отрицательных числах биты противоположны положительным числам и добавлена 1

>> obj.method() - оператор . возвращает Reference Type (ссылочный тип), который передает оператору () информацию о this.
      Если оператор . используется в каком-либо выражении отдельно от оператора (), то Reference Type теряет исходный this.
      Одним из решений данной проблемы является метод bind().

>> Оператор Spread - копирует собственные перечисляемые свойства объекта (без прототипа) в новый объект:
      let newObj = { ...obj }
>> Оператор Rest - собирает входные остаточные аргументы фу-и в один массив.
      function foo(arg1, arg2, ...rest) {}


/////////////
4.   Циклы   
/////////////

>> Циклы игнорируют СИМВОЛЬНЫЕ и НЕПЕРЕЧИСЛИМЫЕ свойства объектов

>> Директивы break/continue поддерживают метки, чтобы выйти из любого уровня вложенности циклов:
      labelName: for (...) {
        ...
        break/continue labelName;
      }


///////////////
5.   Функции   
///////////////

      1. Function Declaration
            - function foo() {} 
            > В [[LexicalEnvironment]] инициализируется мгновенно и полностью
      
      2. Function Expression 
            - let foo = function() {} 
            > Не имеет  this
            > Не имеет  super
            > Не имеет  arguments
            > Не может  быть вызваны с new

      3. Named Function Expression (NFE) 
            - let foo = function bar() {} 
            > Function Expression с именем;
            > Для рекурсивных вызовов;
            > Недоступна за пределами фу-и.

      4. new Function(arg1, argN, functionBody) 
            - let foo = new Function('a', 'b', 'return a + b')
            > [[LexicalEnvironment]] ссылается на глобальное [[LexicalEnvironment]],
                  то есть такая фу-я имеет доступ только к глобальным переменным.

      5. Tagged Template String Literal (теговый шаблон) 
            - tag`first str ${arg1} and ${arg2} third str`.
            > function tag(strings, ...expressions) {} 
                  > strings       - массив строк между ${expression}.
                  > expressions   - массив выражений ${expression}.
                  > strings.raw() - исходная строка.

      6. IIFE (Immediatly Invoked Function Expression) - фу-я, которая выполняется сразу после её объявления.
            - (function () {})()

>> Применение рекурсии:
      - рекурсивные обходы (объект в объекте в объекте...)
      - рекурсивные структуры (связанный список)

>> arguments - массиво-подобный объект содержащий ВСЕ переданные в фу-ю аргументы, не поддерживает методы массивов. 

>> [[LexicalEnvironment]] - скрытый объект, который есть у каждой фу-и и блока кода, описывает их доступ к переменным.
      Содержит:
      - локальные переменные
      - значение this
      - ссылка на внешний [[LexicalEnvironment]]

>> Переменная - свойство спец. внутр. объекта [[EnvironmentRecord]] (хранилище переменных).
      Поиск искомой переменной происходит сначала во внутреннем [[LexicalEnvironment]], 
      затем во внешнем вплоть до глобального объекта.

>> Вложенный setTimeout гарантирует фиксированную задержку после выполнения фу-и.
>> Браузер ограничивается 4 мс минимальной задерожки между более 4 вызовов setTimeout или setInterval.
>> Декораторы (Decorators) - обертка вокруг фу-и, которая изменяет ее поведение.

>> Частичное применение - создание новой фу-и с некоторыми фиксированными аргументами.
      * Пример: double = multiple.bind(null, 2)

>> Каррирование - трансформация фу-и из f(a,b,c) в f(a)(b)(c). 
      Можно создавать частично-примененные фу-и (т.к. каждый аргумент запоминает свою обл. видимости).
      Только для фу-й с фиксированным количеством аргументов.


>> foo.name - имя фу-и.
>> foo.length - ко-во параметров фу-и. Остаточные параметры не считаются.
>> call - принимает список аргументов, apply - принимает псевдомассив.
>> bind - возвращает экзотический объект Bound Function, 
      который фиксирует контекст и аргументы только во время создания.
>> foo.toString() - вернёт тело фу-и в виде строки.
>> new.target - исп. внутри фу-и, чтобы проверить вызвана ли фу-я при помощи new.
>> Исп. Number.isNaN() и Number.isFinite() вместо isNaN() и isFinite().
>> Object.is() идентичен === , кроме 2-х случаев: 
      1. Object.is(NaN, NaN) === true
      2. Object.is(0, -0) === false
>> parseInt(str, radix) - возвращает число из строки в указанной системе счисления (2-36).
      * Пример: parseInt('100px', 10) === 100

>> str.codePointAt(pos) - возвращает число заакодированное в UTF-16.
>> String.fromCodePoint(code) - возвращает строку из числа.

>> [].join.call(arguments) - заимствование метода с помощью call.
>> window.eval(str) - выполняет строку кода str и возвращает результат последнего line. 
      При `use strict` имеет свое [[LexicalEnvironment]].
>> str.padStart(length, str) - заполняет начало целевой строки заданной строкой, 
      пока длинна целевой строки не достигнет заданной длины.
>> str.padEnd(length, str) - как padStart, только заполняет с конца.
>> array.flat(depth) - возвращает массив с уменьшеной мерностью на depth-мерностей.
>> array.flat(Infinity) - возвращает всегда одномерный массив из массива с любым уровнем мерности.
>> array.flatMap(callback) - как array.map, но возвращает одномерный массив.
>> array.toReversed() - как array.reverse(), но возвращает новый массив.

>> date.toUTCString() - возвращает человеко-читаемую дату в виде строки (UTC)
>> encodeURIComponent(string) - кодирует компонент URI (Uniform Resource Identifier)
>> decodeURIComponent(encodedURI) - декодирует компонент URI, созданный с помощью encodeURIComponent

>> Фу-я для проверки числа на чётность: const isEven = (num) => !(num & 1).


///////////////
6.   Объекты    
///////////////

>> Все значения примитивных типов, кроме Null и Undefined, имеют объект-обёртку (wrapper object), 
      который содержит встроенные методы и свойства.
>> Null и Undefined НЕ имеют объектов-оберток. У них нет свойств, методов, прототипов.
>> Все ключи объектов преобразуются в строки (кроме символов и строк).
>> this - указывает на объект перед точкой.
>> Способы определить наличие свойства в объекте:
      1. 'prop' in obj              // Также проверяет прототипы
      2. obj.hasOwnProperty('prop') // Не проверяет прототипы
      3. obj['prop']

>> Варианты преобразования типов (хинты): 
      1. "string"
      2. "number"
      3. "default"

>> [Symbol.iterator]() {} - спец. метод объекта, который вызывают операторы итерирования.
      Позволяет настраивать итерации объекта "вручную". 
      Возвращает объект с методом next(), который вызывается на каждой итерации.

>> [Symbol.isConcatSpreadable]: true - спец. свойство объекта, 
      которое указывает методу array.concat(obj) обрабатывать obj как массив.
      * Пример:     
            let array = [1, 2]
            let obj = { 0: value0, 1: value1 }
            array.concat(obj)  // 1, 2, value1, value2

>> [Symbol.toStringTag]: 'Value' - спец. свойство объекта для настройки toString у объектов.
      Это свойство есть у большей части встроенных объектов.
      Результат === значение этого свойства обернутое в [object Value].

>> Дескриптор свойства - объект, который содержит значение и флаги (атрибуты) свойства.
      > Атрибуты дескриптора для data properties: 
            - value 
            - writable        === false, value нельзя изменить
            - enumerable      === false, свойство игнорируется циклом и Object.keys
            - configurable    === false, нельзя удалить и нельзя изменить значение всех атрибутов с false на true

      > Object.getOwnPropertyDescriptor(obj, propName)       - возвращает дескриптор свойства.
      > Object.getOwnPropertyDescriptors(obj)                - возвращает объект, содержащий дескрипторы всех свойств.
      > Object.defineProperty(obj, propName, descriptor)     - возвращает obj.
      > Object.defineProperties(obj, { prop: descriptor })   - возвращает obj.

>> Клонирование объектов:
      > Deep copy - полная копия объекта включая вложенные структуры.
            1. structuredClone(obj) - только в браузере.
            2. JSON.parse(JSON.stringify(obj)) - не копирует методы, undefined, Symbol, цыклические ссылки.
      > Shallow copy - вложенные объекты передаются по ссылке.
            1. Spread
            2. Object.assign({}, obj)
            3. Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)) - клонирование объекта вместе с флагами.

> Типы свойств:
      - Data properties (свойства-данные)
      - Accessor properties (свойства-аксессоры) 

> Accessor properties - фу-и, которые исп. для получения и присвоения значения, 
      но синтаксически выглядит как свойство объекта:
            let obj = {
                  get propName() {}       - срабатывает при чтении obj.propName
                  set propName(value) {}  - срабатывает при записи obj.propName = value 
            }
  
> Атрибуты дескриптора для accessor properties:
      - get            // { get() { return this.name } }
      - set            // { set(value) { this.name = value } }
      - enumerable
      - configurable

>> Intl - объект для работы со строками, датами, числами, учитывая особенности пердпочитаемого пользователем языка:
      (https://learn.javascript.ru/intl)
      > Intl.Collator ~ str.localeCompare
      > Intl.DateTimeFormat ~ date.toLocaleString + date.toLocaleDateString + date.toLocaleTimeString
      > Intl.NumberFormat ~ number.toLocaleString

>> Сильная ссылка - ссылка на объект, которая предотвращает его удаление сборщиком мусора.
>> Слабая ссылка  - ссылка на объект, которая НЕ предотвращает его удаление сборщиком мусора.
  
>> new WeakRef(target) - объект, содержащий слабую ссылку на target.
>> new FinalizationRegistry(cleanCallback) - объект, который позволяет привязять к target колбэк очистки, 
      который выполниться после удаления target из памяти сборщиком мусора.

>> Object.freeze(obj) - "замораживает" объект: запрещено добавлять, удалять, изменять свойства и методы. Возвращает obj.
>> Object.seal(obj) - "запечатывает" объект: как Object.freeze, но разрешено изменять значения.


/////////////////
7.   Прототипы   
/////////////////

>> [[Prototype]] - скрытое свойство, ссылается на другой объект - прототип; если его нет, то === null.
!!! Замена [[Prototype]] в существующих объектах ОЧЕНЬ медленная операция ( Object.setPrototypeOf и obj.proto = ).

>> obj.__proto__ - это аксессор, то есть getter и setter для [[Prototype]].
>> Операции запись/удаление не работают с прототипом (за исключением свойства-аксессора setter).
>> Object.keys, Object.values и др. Object-свойства игнорируют унаследованные свойства.

>> Foo.prototype = {}/null - определяет __proto__ только для экземпляров new Foo
      (function Foo() {}; obj1 = new Foo(); Foo.prototype = obj2; obj1.__proto__ === obj2)

>> Foo.prototype === { constructor: Foo }
>> obj.__proto__  === arr.__proto__.__proto__ 
                  === func.__proto__.__proto__ 
                  === Number(5).__proto__.__proto__ 
                  === Object.prototype

>> obj.join = Array.prototype.join - заимствования метода с помощью prototype.
>> Вместо __proto__ : 1. Object.create(proto, [descriptor]) // создает {} со свойством [[Prototype]] и дескриптором
                      2. Object.getPrototypeOf(obj)         // возвращает [[Prototype]]
                      3. Object.setPrototypeOf(obj, proto)  // устанавлиавает [[Prototype]]

>> clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))
>> Простейший ассоциативный массив - создаётся через new Map, Object.create(null), obj.__proto__ = null.
>> obj['__proto__'] = 'someValue' // присвоение проигнорируется.


//////////////
8.   Классы   
//////////////

>> Класс - шаблон кода для создания объектов, который устанавливает их начальные свойства и методы

>> [[IsClassConstructor]]: true - спец. внутр. свойство фу-и, созданной с помощью class.
>> Методы и constructor - сохраняются в SomeClass.prototype.
>> Методы класса неперечисляемы.
>> Классы всегда используют 'use strict'.
>> (Named) Class Expression - аналог (Named) Function Expression.

>> class Child extends Parent: 
      - Child.prototype.__proto__ === Parent.prototype
      - после extends разрешены любые выражения

>> super.method() - вызывает родительский метод.
>> super()        - вызывает конструктор родителя (работает только в дочернем конструкторе).

>> При отсутсвии конструктора, вызывается пустой конструктор: 
      > constructor(...args) { super(...args) }

>> Конструкторы в дочерних классах должны вызывать конструктор родителя (super()) перед использованием this.

>> [[ConstructorKind]]: 'derived' - спец. внутр. свойство функции-конструктора дочернего класса.
      При таком значени дочерний конструктор ожидает вызова конструктора родительского класса, 
      который создаст пустой объект и присвоет его this.
      Поэтому, если мы создаем конструктор в дочернем классе, необходимо вызвать super,
      иначе объект для this не будет создан и мы получим ошибку.
      
>> Поля дочернего класса инициализируются после вызова super.

>> [[HomeObject]] : 
      - спец. внутр. свойство методов класса (объекта) и оно равно этому классу (объекту)
      - используется только в super, чтобы получить прототип родителя и его методы
      - нельзя изменить, поэтому копировать метод использующий super, между объектами небезопасно
      - в объектах работает только в методах объявленных как method()

>> Статические свойства и методы класса:
      - наследуются дочерним классом ( Child.[[Prototype]] = Parent ) 
      - НЕ наследются от встроенных классов
      - this === сам класс ( по аналогии с объектами )
      - НЕДОСТУПНЫЕ экземплярам класса
      - Синтаксис: 
            1. class MyClass {
                  static property = ...
                  static method() { ... }
            };

            2. MyClass.property = ...
               MyClass.method   = ...
              
>> Защищенные методы и свойства по соглашению JS-программистов:
      - доступны только внутри класса
      - начинаются с префикса ' _ '
>> Приватные методы и свойства:
      - начинаются со спец. символа ' # '
      - доступны исключительно внутри класса
      - не наследуются
      - не конфликтуют с публичными
      - не работает с this ( this['#prop'] - не работает )

>> [Symbol.species] - спец. статический getter, который должен вернуть конструктор,
      который будет использован для создания новых объектов.
      * Пример: 
            class ExtendedArray extends Array {
                  static get [Symbol.species]() { return Array }
            }           
            const array = new ExtendedArray(1, 2, 3, 4, 5)
            const filteredArray = array.filter(item => item >= 3)
            ( filteredArray.__proto__ === array.__proto__ ) // false
      
>> instanceof - оператор проверяет, принадлежит ли объект указанному классу, с учетом наследования.
      Алгоритм работы: 
            1. Если в классе есть статичный метод [Symbol.hasInstance], то вызвать его и вернуть true/false:
                  * Пример:
                        class Animal {
                              static [Symbol.hasInstance](obj) { if (obj.catEat) return true }
                        }
                        let obj = { catEat }
                        ( obj instanceof Animal ) // true
            2. Проверка на равенство прототипа класса какому либо прототипу в прототипной цепочке объекта: 
                  ( Class.prototype === obj.__proto__ )
                  ( Class.prototype === obj.__proto__.__proto__ ) и т.д.

>> objA.isPrototypeOf(objB) - аналог instanceof: ( obj instanceof Class === Class.prototype.isPrototypeOf(obj) )

>> Примеси (Mixins) - класс, методы которого предназначены для расширения других классов без наследования от примеси.
      - Примесь необходимо скопировать в прототип расширяемого класса ( Object.assign(ClassName.prototype, mixin) )
      - Примесь перезаписывает существующие методы класса

>> JavaScript НЕ поддерживает множественное наследование, то есть объект может иметь только один [[Prototype]].
      Вместо него используют Mixins.


//////////////
9.   Symbol  
//////////////

      1. Symbol.for(key)            - получить символ по ключу из глобального реестра символов
      2. Symbol.keyFor(symbol)      - получить ключ по символу из глобального реестра символов
      3. Object.getOwnPropertySymbols(obj) - получить массив только символьных ключей  
      4. Reflect.ownKeys(obj)       - получить массив всех ключей
      5. Symbol.toPrimitive         - позволяет описать правила преобразования объекта в примитив

>> Свойства, чьи ключи Символы игнорируются оператором 'in' и Object.keys()


/////////////////
10.  Замыкание   
/////////////////

>> Замыкание - это способность фу-и запоминать свои внешние переменные 
      и получать к ним доступ с помощью скрытого свойства [[Environment]]   
      ( https://learn.javascript.ru/closure ).

      * Пример:
            let f3 = f1()
            let f4 = f1()

            f3() // 2
            f3() // 3
            f4() // 4
            f4() // 5

            function f1() {
                  let x = 1
                  return function f2() {
                        console.log(++x)
                  }
            }


////////////////////////
11.  Обработка ошибок
////////////////////////

>> try {} catch() {} finally {} - работает синхронно, то есть ассинхронный код игнорируется
      - finally выполняется всегда, в т.ч. после return 
      - при возникновении ошибки JS генерирует объект ошибки и передает как аргумент в блок catch
      - catch должен обрабатывать только известные ему ошибки, а остальные пробрасывать ( throw error )

>> throw <объект ошибки> - оператор генерирующий ошибку.
>> window.onerror = function (message, url, line, column, error) {} - глобальный catch
>> Расширение встроенных классов ошибок:
      - class MyError extends Error
      - вызвать super
      - изменить name ( this.name = this.constructor.name - чтобы не прописывать вручную name)

>> instanceof - использовать для проверки типа ошибок (при расширении классов ошибок).
>> Алгоритм обёртывание исключений: фу-я ловит все низкоуровневые исключения и создает 1 высокоуровневое.
      

/////////////////////
12.  Асинхронность   
/////////////////////

>> Асинхронность в JS на самом деле является автоматизированным управлением потоками, которое обеспечивается окружением:
      - Браузер (Web API)
      - Node (Thread Pool)

>> new Promise(function(resolve, reject) { <executor> })
      .then(function(result) {}, function(error) {})
      .catch(function(error) {})
      .finally(function() {})

      1. executor       - фу-я-исполнитель, которая запускается сразу после создания Promise
      2. resolve(value) - встроенный callback, который необходимо вызвать при успешном выполнении executor
      3. reject(error)  - встроенный callback, который необходимо вызвать при ошибке в executor
      4. Объект класса Promise обладает внутренними свойствами:
            > state (состояние - может быть изменено только 1 раз): 
                  - pending   (ожидание)
                  - fulfilled (выполнено успешно)
                  - rejected  (выполнено с ошибкой)
            > result (в зависимости от state):
                  - при pending     === undefined
                  - при fulfilled   === value
                  - при rejected    === error
      5. then - возвращает Promise и выполняет:
            > 1-й callback при state === fulfilled
                  - возвращаемое значение становится результатом выполнения Promise и передается в следующий .then 
            > 2-й callback при state === rejected
      6. catch - укороченный вариант для .then(null, function(error) {})
      7. finally - метод, который:
            > выполнится в любом случае
            > ничего не возвращает
            > пропускет result или error дальше, к следующему then/catch

            
>> Если callback в .then/.catch/.finally возвращает new Promise,
      последующие элементы цепочки ждут, пока выполнится new Promise.

>> thenable - отличительное свойство объекта содержащего метод .then, который можно вернуть как Promise.
      Если фу-я возвращает объект с пользовательским методом .then, то интерпретатор обрабатывает его
      как Promise и вызывает его метод .then, после чего передает ему встроенные resolve и reject.

>> fetch - возвращает Promise, который возвращает объект response ПОСЛЕ того, 
      как удаленный сервер присылает ЗАГОЛОВКИ ответа, но ДО того, как ВЕСЬ ОТВЕТ сервера полностью загружен.

>> Promise и его колбэки обладают скрытым try-catch, то есть ошибки обрабатываются по ходу выполнения кода (синхронно).
>> Проброс ошибки (throw) в catch работает аналогично пробросу в try-catch.

>> 'unhandledrejection' - событие, которое срабатывает при наличии необработанных ошибок.
      Возникает, когда все промисы (микрозадачи) завершены и какой-либо из них "rejected"
      Основные свойства:
          - event.promise // [object Promise] - Promise, который сгенерировал ошибку
          - event.reason  // Объект ошибки, которая не была обработана

>> Методы класса Promise:
    1. Promise.all            - ждет, пока все переданные промисы выполнятся УСПЕШНО (или 1-ю ошибку)
    2. Promise.allSettled     - ждет, пока все переданные промисы ЗАВЕРШАТСЯ
    3. Promise.race           - ждет 1-й ЗАВЕРШЕННЫЙ промис
    4. Promise.any            - ждет 1-й УСПЕШНО выполненный промис
    5. Promise.resolve/reject - возвращает промис успешный/с ошибкой (async-await заменяет эти методы)

>> Промисификация - создание фу-и-обертки, которая принимает в качестве параметра callback и возвращает Promise, 
      который вызывает этот callback.

>> PromiseJobs (mikrotask queue) - очередь микрозадач (.then/.catch/.finally попадают в очередь).
      Движок выполняет задачи из очереди, когда он выполнит основной код.
                                    
>> async - оператор, который оборачивает фу-ю в Promise:
            - работает для методов класса
            - для обработки финального результата/ошибки использовать .then/.catch
            
>> await - оператор, который заставляет интерпретатор ждать, пока Promise не выполнится:
            - работает с thenable-объектами
            - для обработки ошибок использовать try-catch
 
>> Условия для async-итерации:
      1. [Symbol.asyncIterator] - вместо [Symbol.iterator]
      2. next() - должен возвращать Promise
      3. Для итерации по объекту исп. только for await


//////////////////
13.  Генераторы
//////////////////

>> При вызове возвращает спец. объект - генератор [object Generator]:
      function* generateSequence() {
            yield 1
            yield 2
            return 3 // <!>
      }
> let generator = generateSequence() - перебираемый объект ( <!> цикл не возвращает значение return )
> generator.next() - выполняет код фу-и до ближайшей инструкции 'yield', после чего останавливается.
      Возвращает объект { value: 'value', done: true/false }
            - true в случае завершения выполнения фу-и (или return)
      
>> Генераторы можно генерировать бесконечно (например, с помощью цикла в теле функции-генератора).
>> Для создания перебираемых объектов обычно исп. генератор  - *[Symbol.iterator].
>> *[Symbol.iterator]() {} - сокращенная запись для [Symbol.iterator]: function* () {}.
>> yield* - инструкция, которая делегирует выполнение другому генератору.
>> Композиция генераторов - возможность встраивать генераторы друг в друга с помощью инструкции 'yield*'.
      * Пример: 
            function* generateSequnce(start, end) {
                  for (let i = start; i !== end; i++) yield i
            }
            function* generateAnotherSequence() {
                  yield* generateSequence(1, 5)
                  yield* generateSequence(5, 10)
            }

>> yield и next могут обмениваться значениями:
      - yield передает значение объекту, который возвращает текущий 'next'
      - next(arg) передает arg в генератор, после чего arg становиться результатом предыдущего выражения yield
            * Пример: 
                  console.log(yield 1) // generator.next().value  === 1           // в консоле выведет 4
                  console.log(yield 2) // generator.next(4).value === 2           // в консоле выведет 9
                  console.log(yield 3) // generator.next(9).value === 3           // в консоле выведет 16
                                       // generator.next(16).value === undefined

>> throw - метод инициирующий ошибку на последнем сработавшем yield: generator.throw(new Error()).
>> Async-генератор:
      - необходимо добавить async
      - next возвращает Promise 
      - перебирать генератор только с помощью for await 
>> Для создания async-перебираемых объектов обычно исп. async-генератор - async *[Symbol.asyncIterator].


//////////////
14.  Модули
//////////////

>> Модуль - файл со скриптом.

>> export - отмечает переменные и фу-и, которые должны быть доступны вне модуля
>> import - импортирует функциональность из других модулей.

>> Свойства модулей:
      1. В модуле всегда используется режим 'use strict'
      2. Каждый модуль имеет свою обл. видимости
      3. Импортируемый код выполняется 1 раз
      4. Изменения импортируемых данных видят все импортеры
      5. В модуле this === undefined ( в не-модуле this === window )
      6. Модуль выполняется в отложенном режиме (deferred):
            - ожидает полной загрузки HTML
            - выполняется в порядке очереди относительно других модулей
            - выполняется перед событием DOMContenLoaded
      7. Модули с одинаковым src выполняется 1 раз
      8. Модуль загружаемый с другого домена требует указания заголовков CORS

>> export default - экспорт по умолчанию: 
      - в модуле может быть только 1 такой экспорт
      - при импорте такого экспорта {} не нужны
      - экспортируемая сущность не обязана иметь имя
      - export { foo as default } - экспорт отдельно от объявления
      - при import * as foo, доступ к export default через foo.default

>> export ... from ... - реэкспорт:
      - позволяет импортировать функционал и одновременно его экспортировать 
      - исп. для возможности импортировать весь функционал из 1 "главного" файла

>> export { default } from ... - реэкспорт по умолчанию.
>> import 'module' - запустит код импортируемого модуля.
>> import('module') - динамический импорт:
      - загружает модуль и возвращает Promise
      - можно исп. в любом месте кода
      - работает в скрипте не-модуле
      - внутри async фу-и можно исп. await import('module')
      - это спец. фу-я (аналог super())

>> import.meta
	= содержит мета-данные модуля (например URL модуля)

>> Нельзя исп. деструктурирующий import для export default {...} (экспорт объекта по умолчанию).
      Синтаксис и семантика import/export отличается от обычного объекта.
      (https://stackoverflow.com/questions/43814830/destructuring-a-default-export-object).


////////////////////////////
15.  Регулярные выражения
////////////////////////////

>> Создание regexp:
      a. let regexp = new RegExp('шаблон', 'флаги') - можно использовать переменные
      b. let regexp = /шаблон/флаги - только статичный текст
    
>> Флаги:
      i - поиск не зависит от регистра
      g - поиск ищет ВСЕ совпадения (иначе только первое)
      m - многострочный режим (только для якорей ^ и $, чтобы искать в каждой строке разделённых переносом строки \n)
      s - режим dotall ( . === /n)
      u - полная поддрежка Юникода
      y - поиск на конкретной позиции в тексте
      d - результат помещается в массив

>> Символьные Классы:
      \d - цифра (0-9)
      \s - пробельные символы
      \w - буквы латинского алфавита, _, цифры
      \p{...} - юникодные свойства. Работает только с флагом u. Описывают категорию символа: L, N, P, и т. д. 
            "123 test".match(/\p{L}/gu) === t,e,s,t
      .  - любой символ, кроме \n (с флагом s будет учитывать и \n)
      ^ - начало строки
            /^\d/.test("1. Test") === true
      $ - конец строки
            /st$/.test("2. Test") === true
      ^...$ - полное совпадение строки
            /^test$/.test("test") === true
      \b...\b - ищет слово (начинается на \w, заканчивается не \w)
            "JavaScript Java Script".match(/\bJava\b/g) === Java
      [...] - искать один символ соответствующий какому-либо из переданных (диапазону) символов, символьных классов
      [^...] - искать любые символы кроме указанных
            "abc".match(/[abc])    === a
            "abc".match(/a[a-z]/)  === ab
            "1bc".match(/[^0-9]+/) === bc
      | - альтернация, как [...], но работает не с символами, а с любыми выражениями
            "00:00 10:10 23:59 25:99 1:2".match(/([01]\d|2[0-3]):[0-5]\d/g) === 00:00, 10:10, 23:59

>> Квантификаторы - пишутся после символа, который нужно искать какое-то число раз:
      + - 1 и более раз
      * - 0 и более раз
      ? - 0 или 1 раз
      {n} - n раз (после n через кому можно указать дополнительное число раз: {1,2} - 1 или 2 раза)

>> Обратный Символьный Класс - класс, который исключаюет другой соответствующий класс (Например: \D, \S, \W)

>> Методы:
      > str.match(regexp) - ищет совпадения 
            - без скобочных групп
            - если совпадений нет, возвращает null

      > str.matchAll(regexp) - ищет совпадения
            - со скобочными группами
            - возвращает перебираемый объект (Array.from, чтобы сделать из него массив)
            - если совпадений нет, возвращает пустой перебираемый объект

      > str.replace(str|regexp, str|function) - универсальный метод поиска и замены в строке
            - во 2-м аргументе (строка замены) можно использовать спец. символы (см. Подстановки)
            - во 2-м аргументе может быть фу-я - её результат будет вставлен в качестве замены
                  > func(match, p1, ..., pn, offset, input, groups)
                        1. match - найденное совпадение
                        2. p1, ..., pn - содержимое скобочных групп
                        3. offset - позиция, на которой найдено совпадение
                        4. input - исходная строка
                        5. groups - объект с содержимым именованных скобочных групп

      > str.split(regexp|substr, limit) - разбивает строку по разделителю regexp или substr
      > str.search(regexp) - возвращает позицию 1-го совпадения или -1, если совпадений нет                 

      > regexp.exec(str) - аналогичен str.match(regexp)
            > при наличии флага g или y позволяет читать/записывать свойство regexp.lastIndex
            > при наличии флага g
                  - regexp.lastIndex - позиция начала поиска каждого следующего совпадения
                  - если совпадений больше нет, то regexp.exec(str) возвращает null, а regexp.lastIndex === 0
            > при наличии флага y
                  - regexp.lastIndex - ищет исключительно на позиции lastIndex

      > regexp.test(str) - если есть хоть одно совпадение, то возвращает true, иначе false
            !!! имеется свойство regexp.lastIndex
            !!! после использования lastIndex меняется на следующий

>> Для поиска символов [ ] / \ ^ $ . | ? * + ( ) необходимо их экранировать

>> Символьные классы - сокращение для наборов символов:
      \d === [0-9]
      \w === [a-zA-Z0-9_]
      \s === [\t\n\v\f\r]

>> Режимы квантификаторов:
      1. Жадный  - повторяет квантификатор максимальное число раз. 
            Если строка закончилась, поиск возвратится до ближайшего совпадения оставшегося шаблона.
            Режим работает по умолчанию.
      2. Ленивый - ищет совпадения для оставшегося шаблона перед каждым повторением квантификатора.
            Режим включается знаком ? после квантификатора.

>> Скобочная группа:
      1. Квантификаторы применяются ко всему содержимому скобок
      2. Скобочные группы поочередно сохраняются в результируюющий массив:
            - можно повторно исп. содержимое скобочных групп внутри regexp: начало с \1 и продолжается рекурсивно
            - не работает с флагом g
            - если скобочная группа необязательна (квантификатор ?), она все равно будет в результате как undefined
      3. str.matchAll(regexp):
            - возвращает перебираемый объект (Array.from(obj), for (let array of obj), [array1, array2] = obj)
            - с флагом g каждое совпадение это массив со скобочными группами
            - если совпадений нет, возвращает пустой перебираемый объект
      4. (?<name>...) - именование скобочной группы
            - именованные группы находятся в array.groups
      5. str.replace(regexp, replacement) - в строке замены replacement можно использовать содержимое скобочных групп:
            - по номеру скобочной группы ( $n )
                  >> 'aaa bbb'.replace(/(\w+) (\w+)/, '$2 $1') === 'bbb aaa'
            - по имени скобочной группы ( $<name> )
                  >> 'a b'.replace(/(?<name1>a) (b)/, '$name1 $name1') === 'a a'
      6. ?: - исключает содержимое скобочной группы из результата
            >> 'a b'.match(/(?:\w) (\w)/)
    
>> Обратные ссылки в шаблоне (доступ к скобочным граппам в шаблоне):
      \number - по номеру скобочной группы
      \<name> - по имени скобочной группы

>> Подстановки (шаблон замены - метод replace):
      $$ - подставляет знак $
      $& - подставляет совпадение полностью 
      $n - подставляет совпадение группы под номером n
      ${name} - подставляет совпадение группы с именем name

>> Проверки:
      - при нескольких проверках подряд для совпадения необходимо выполнение всех проверок
      - чтобы Y был в результате, его необходмо обернуть в скобки
            X(?=Y) - ищет X, если за ним Y
            X(?!Y) - ищет X, если за ним НЕ Y
            (?<=Y)X - ищет X, если перед ним Y
            (?<!Y)X - ищет X, если перед ним НЕ Y


///////////
16.  DOM
///////////

>> Document Object Model (DOM) - древовидная модель взаимосвязей HTML-объектов, и её API.

>> Свойства и методы:
+ Свойства узлов
      elem.nodeType           - тип узла. [number, read only].
      elem.tagName            - имя тега элемента. [read only].
      node.nodeName           - имя/тип узла. [read only].
      elem.innerHTML          - HTML-содержимое элемента.
      elem.outerHTML          - HTML-элемент. Изменятся элемент в DOM, но не содержимое переменной.
      textNode.data/nodeValue - содержимое ТЕКСТОВОГО узла.
      elem.textContent        - текст внутри элемента.
      
+ HTML-атрибуты
      elem.hasAttribute(name)        - проверить наличие атрибута.
      elem.getAttribute(name)        - получить значение атрибута.
      elem.setAttribute(name, value) - установить значения атрибута.
      elem.removeAttribute(name)     - удалить атрибут.
      elem.attributes                - коллекция атрибутов в виде объектов со свойствами name и value.

+ Поиск элементов:
      elem.matches(css)          - проверяет удовлетворяет ли элемент селектору CSS. [true/false].
      elem.closest(css)          - ищет ближайшего предка, включая сам элемент.
      elemA.contains(elemB)      - true, если elemB внутри elemA или elemA === elemB, иначе false.
      elem.querySelector(css)    - находит первый подходящий элемент.
      elem.querySelectorAll(css) - находит все подходящие элементы.
      elem.getElementById(id)    - находит элемент по id.
      elem.getElementsByClassName(class) -|
      elem.getElementsByTagName(tag) -----|--> возвращают коллекцию, которая обновляется при изменениях.
      elem.getElementsByName(name) -------|

+ Создание и изменения узлов
      document.createElement(tag)     - создать элемент с заданным тегом.
      document.creatTextNode(text)    - создать текстовый узел с заданным текстом.
      node.prepend(node | string)     - добавить узел в начало.
      node.append(node | string)      - добавить узел в конец.
      node.before(node | string)      - добавить узел перед узлом.
      node.after(node | string)       - добавить узел после узла.
      node.replaceWith(node | string) - заменить узел на заданный узел.
      node.remove()                   - удалить узел.
      node.cloneNode(true | false)    - возвращает клон элемента с/без дочерними элементами.
      insertAdjacentHTML(where, html)     - вставляет html    | where:
      insertAdjacentText(where, string)   - вставляет текст   |  beforebegin/afterend  - до/после элемента.
      insertAdjacentElement(where, elem)  - вставляет элемент |  afterbegin/beforeend - начало/конец элемента.

+ Стили и классы
      elem.style - спец. объект стилей. Имена свойств CSS в JS преобразуются по принципу: дефис -> большая буква.
!!!         Оперирует только атрибутом style в HTML, не имеет доступа к стилям из <style> и файлов CSS.
      elem.style.cssText - строка, содержащая ассоциативный массив CSS. 'prop1: value1; prop2: value2;'
      elem.className     - строка с набором всех классов через пробел. 'class1 class2 class3'
      elem.classList     - перебираемый объект, содержащий список и методы добавления/удаления классов.
      elem.classList.add(string)      - добавить класс.
      elem.classList.remove(string)   - удалить класс.
      elem.classList.toggle(string)   - добавить класс, если его нет, удалить - если есть.
      elem.classList.contains(string) - проверяет наличие класса. [true/false].
      elem.style.anyProperty = "" - присвоить свойству пуйстую строку, чтобы сбросить стиль (вместо удаления).
      getComputedStyle(elem) - возвращает объект с вычисленными стилями.
            - аналог elem.style, но с учётом <style> и файлов CSS
            - значения свойств всегда в абсолютных величинах (пиксели)
            - содержит только полные значения (paddingTop, но не padding)
            - не даёт доступа к псевдоклассу :visited

+ Размеры и прокрутка элементов
      elem.getBoundingClientRect() - возвращает объект, содержащий координаты elem.
      document.elementFromPoint(x, y) - возвращает самый глубоко вложенный элемемент в окне по координатам.
      elem.offestParent - ближайший позиционированный предок элемента. null для элементов position: fixed.
      elem.offsetLeft/offsetTop - координаты относительно левого верхнего угла offsetParent. (read only).
      elem.offsetWidth/offsetHeight - ширина/высота элемента включая border. (read only).
      elem.clientLeft/clientTop - отступы внутренней части элемента от внешней (часто равны border). (read only).
      elem.clientWidth/clientHeight - контент + padding, без прокручиваемой области. (read only).
      elem.scrollWidth/scrollHeight - контент + padding, и вся прокручиваемая область. (read only).
      elem.scrollLeft/scrollTop - ширина/высота уже прокрученного контента.
!!!         Не стоит брать width/height из CSS.
      document.documentElement.clientWidth/clientHeight - ширина/высота окна, за вычетом полосы прокрутки.
      window.innerWidth/innerHeight - ширина/высота окна браузера вместе с полосой прокрутки.
      window.pageXOffset/pageYOffset -| ширина/высота прокрученной области страницы.
      window.scrollX/scrollY ---------┘
      window.scrollBy(x, y) || (options) - прокручивает страницу ОТНОСИТЕЛЬНО её текущего положения. 
      window.scrollTo(x, y) || (options) - прокручивает страницу на АБСОЛЮТНЫЕ координаты. 
                                options === {
                                    top: x,
                                    left: y,
                                    behavior : "auto"||  "instant" || "smooth"
                                }
      elem.scrollIntoView(top) || (options) - прокручивает страницу так, чтобы elem находился вверху/внизу 
                                   options === {                                         (top = true/false).
                                          behavior:  "auto" || "instant" || "smooth",
                                          block: "start" || "center" || "end" || "nearest",
                                          inline: "start" || "center" || "end" || "nearest"
                                   }
!!!   Получить полную высоту документа:
            let scrollHeight = Math.max(
                  document.body.scrollHeight, document.documentElement.scrollHeight,
                  document.body.offsetHeight, document.documentElement.offsetHeight,
                  document.body.clientHeight, document.documentElement.clientHeight
            )
      document.body.style.overflow = 'hidden' - делает документ не прокручиваемым, но исчезает полоса прокрутки.

+ Устаревшие методы и свойства
      parentElem.appendChild(node)               - добавить node в конец parentElem.
      parentElem.insertBefore(node, nextSibling) - добавить node перед nextSibling.
      parentElem.replaceChild(node, oldChild)    - заменить oldChild на node.
      parentElem.removeChild(node)               - удалить node.
      document.write(html) - во время загрузки страницы на ходу записывает в неё HTML (работает очень быстро).
            Если вызвать после окончания загрузки страницы, её содержимое затрётся. 

>> Наборы ссылок:
      > Для всех узлов: childNodes, parentNode, firstChild, lastChild, previousSibling, nextSibling.
      > Для элементов: children, parentElement, firstElementChild, lastElementChild, previousElementChild, nextElementChild.

>> DOM-узлы представляют собой обычные экземпляры соответствующих классов в JS.
   Классы DOM описываются в Interface Description Language (IDL).
   Пример классов DOM:
      1. EventTarget
      2. Node
      3. Element
      4. HTMLElement и т.п.

>> Особенности HTML-атрибутов:
      > Стандартные атрибуты в HTML-элементах соответствуют свойствам этих элементов в JS-коде.
      > HTML-атрибуты регистронезависимы и их значения всегда строки.
      > Значение некоторых HTML-атрибутов нельзя изменить в JS-коде.
      > data-атрибуты доступны в свойстве элемента dataset: 
            HTML: <a data-foo-bar="value"> ---> JS: a.dataset.fooBar

>> DocumentFragment - класс, позволяющий создавать обёртку вокруг набора узлов.
      Когда обёртку куда-либо применяют, она исчезает и остаётся только её содержимое.

>> Свойства элемента <select>: 1. select.options, 2. select.value, 3. select.selectedIndex

>> Формы:
      > document.forms - именованная коллекция форм. 
            (document.forms.somename === document.forms[0])
      > document.forms.elements - именованная коллекция элементов формы, 
            также коллекция коллекций одноименных элементов формы.
            (document.forms.elements.somename === document.forms.elements[0])
      > Форма ссылается на все свои элементы, а все элементы ссылаются на свою форму (element.formname).
      > form.submit() - отправляет форму, при этом событие 'submit' НЕ срабатывает.


///////////////
17.  События
///////////////

>> Event Propagation - свойство события распостранятся иерархично от объекта Window до вызвавшего это событие элемента,
      то есть на каждом проходном элементе вызывается обработчик, если он есть.
      > Фазы Event Propagation:
            - Capturing (погружение) - от Window до цели (по умолчанию эта фаза выкл).
            - Target - достигнут целевой элемент.
            - Bubbling (всплытие) - от цели до Window.                

>> Способы назначить обработчик событий:
      1. Атрибут элемента on<ИмяСобытия>
      2. Свойство элемента on<ИмяСобытия>
      3. elem.addEventListener(event, handler, [options]):
            > event - имя события
            > handler - ссылка на функцию, или объект класса с методом handleEvent(event) {}
            > options === 1. true/false - фаза срабатывания обработчика: погружение/всплытие
                          2. {
                                    once: true/false    - после выполнения обработчик удалить/неУдалять
                                    capture: true/false - фаза срабатывания обработчика: погружение/всплытие
                                    passive: true/false - если true, то сообщает браузеру, что обработчик не вызовет
                                          preventDefault(), и браузер сразу выполнит действие по умолчанию, 
                                          не ожидая других обработчиков.
                              }

> elem.removeEventListener(event, handler, [options]) - удаляет обработчик события handler (нужна та же фаза).
> event.preventDefault() - отменить действие браузера по умолчанию.
> event.defaultPrevented - если true, то событие по умолчанию отменено (лучше чем event.stopPropagation()).
> event.stopPropagation() - останавливает всплытие дальше.
> event.stopImmediatePropagation() - предотвращает всплытие включая текущий элемент.
> event.eventPhase - фаза, на которой сработал обработчик (погружение = 1, фаза target = 2, всплытие = 3).
> event.currentTarget === this - элемент, на котором в данный момент выполняется обработчик (меняется по мере всплытия).
> event.target - самый глубоко вложенный элемент, на котором сработал слушатель (не изменнен в процессе всплытия).
> event.buttons - возвращает номер кнопки мыши (0 - левая, 1 - средняя, 2 - правая и т.д.).
> event.clientX/clientY/pageX/pageY - координаты курсора относительно окна/документа.

>> События клавиатуры:
      > 'keydown' - срабатывает при нажатии клавиши
      > 'keyup'   - срабатывает при отпускании клавиши

>> Автоповтор - при долгом нажатии клавиши, событие 'keydown' срабатывает повторно, пока не сработает 'keyup'.
>> event.repeat === true - для событий вызванных автоповтором.

>> Клавиши-модификаторы: event.shiftKey - клавиша Shift         | - true, если нажаты во время срабатывания события
                         event.altKey   - клавиша Alt           |
                         event.ctrlKey  - клавиша Ctrl          |
                         event.metaKey  - клавиша Cmd для Mac   |

>> event.key - символ нажатой клавиши (буква, цифра, Enter, Tab, F1 и т.д.).
>> event.code - код нажатой клавиши (Key<буква>, Digit<цифра>, Enter, Tab, F1 и т.д.).

>> Делегирование событий - один обработчик на общего предка обрабатываемых элементов.
      Способы делегирования: 
            1. Простые проверки
            2. Атрибуты data- (этот способ называют "behavior" (поведение))

>> Создание пользовательских событий:
      1. new CustomEvent(type, options) - лучший способ для пользовательских событий
            > type - строка с названием события.
            > options === {
                  bubbles: true/false    - всплытие разрешить/запретить
                  cancelable: true/false - отмену события по умолчанию разрешить/запретить
                  composed: true/false   - всплытие за пределы Shadow DOM разрешить/запретить 
                  detail: { ... }        - объект для передачи любых пользовательских данных обработчику событий
            }

      2. new Event(type, options) - как CustomEvent, только без свойства detail в options.
      3. Конструкторы различных UI Event: UIEvent, FocusEvent, MouseEvent, WheelEvent, KeyboardEvent, ...

>> elem.dispatchEvent(event) - запускает объект-событие event на elem. 
                               Возвращает false, если какой-либо обработчик события вызвал event.preventDefault().

>> В событиях 'mouseover'/'mouseenter': event.target        - элемент, НА который курсор перешел.
                                        event.relatedTarget - элемент, С которого курсор ушел (может быть null).
>> В событиях 'mouseout'/'mouseleave': event.target         - элемент, С которого курсор ушел.
                                       event.relatedTarget  - элемент, НА который курсор перешел (может быть null).
>> В событиях 'mouseover'/'mouseout' курсор всегда над самым глубоко вложенным элементом.
>> События 'mouseenter'/'mouseleave' как 'mouseover'/'mouseout', но: 1. Не срабатывают на children;
                                                                     2. Не всплывают (невозвожно делегирование).
>> Событие 'scroll' срабатывает при прокрутке страницы.
>> document.elementFromPoint(clientX, clientY) - возвращает наиболее глубоко вложенный элемент по заданным координатам.
>> Базовый алгоритм Drag'n'Drop:
      1. Подготовить к перемещению элемент:
            - mousedown
            - ondragstart return false
            - position absolute
            - z-index 1000
      2. Перемещать элемент:
            - mousemove
            - left top event.pageX event.pageY
      3. Если нужно, узнать, над каким элементом (droppable) в данный момент находится переносимый элемент (draggable):
            - elem.hidden true -> elemBelow document.elementFromPoint -> elem.hidden false
      4. Остановить перенос:
            - mouseup
            - removeEventListener mousemove mouseup

>> Свойства Pointer Events:
      1. Свойства, что и у Mouse Events.
      2. pointerId - id указателя, который вызвал событие (число генерируется движком).
      3. pointerType - тип указателя. Строковое значение: 'mouse'/'pen'/'touch'.
      4. isPrimary === true для основного (1-го) указателя, который вызвал событие.
      5. width/height - ширина/высота области соприкосновения указателя с устройством. === 1, если не поддерживается устройством.
      6. pressure - степень давления указателя в диапазоне от 0 до 1. === 0.5, если не поддерживается устройством.
      7. tangentialPressure - нормализованное тангенциальное давление.
      8. tiltX/tiltY/twist - положение пера относительно сенсорной поверхности.

>> События указателя (Pointer Events) аналогичны Mouse Events: 'pointer<событие>' аналог 'mouse<событие>'.
>> Событие указателя 'pointercancel' - срабатывает, когда действие с указателем прерывается 
      и события указателя больше не генерируются. 
      Причины срабатывания 'pointercancel':
            - выключение устройства
            - нажатие кнопки "Home"
            - смена ориентации устройства в пространстве
            - сработало событие по умолчанию
            - превышение максимально допустимого количества нажатий на экран
            - движок решил, что нажатие вызвано случайно

>> Событие 'gotpointercapture' - срабатывает при захвате указателя (setPointerCapture).
>> Событие 'lostpointercapture' - срабатывает при освобождении от захвата указателя 
      (pointerup, pointercancel, releasePointerCapture).
>> elem.setPointerCapture(pointerId) - привязывает все дальнейшие Pointer Events с указанным pointerId к элементу.
      Захват указателя упрощает Drag'n'Drop.
      Освобождается от захвата при:
            1. Событии 'pointerup';
            2. Событии 'pointercancel';
            3. Удалении элемента из документа;
            4. Вызове elem.releasePointerCapture(pointerId).

>> { touch-action: none; } - CSS-свойство, чтобы предотвратить срабатывания события по умолчанию.

+ Устаревшие события, методы и свойства
      event.which - возвращает номер кнопки мыши (0 - левая, 1 - средняя, 2 - правая и т.д.);
      event.keyCode - аналог event.key;
      'keypress' - срабатывает, когда нажимается клавиша создающая символ.

>> Событие 'focus' / 'blur'- срабатывает во время фокусировки элемента / при потере фокусировки на элементе. НЕ всплывают.
>> События 'focusin' / 'focusout' - аналог 'focus'/'blur', но всплывают.
>> elem.focus() / elem.blur() - устанавливает/снимает фокусировку на элементе (НЕ работает в Firefox).
>> Атрибут tabindex (или свойство elem.tabindex) включает возможность фокусировки для любого элемента
      с установкой приоритета:
            1. tabindex="-1" - только программная фокусировка (Tab не фокусирует элемент)
            2. tabindex="0" - в одинаковом приоритете с фокусируемыми элементами без tabindex
            3. tabindex="1" - переключение фокуса по порядку чисел

>> document.activeElement - текущий элемент с фокусом.

>> Событие 'change' - срабатывает по окончанию изменения элемента (для текстовых полей после потери фокуса).
>> Событие 'input' - срабатывает ПОСЛЕ изменения значения (event.preventDefault() не работает).
>> События 'cut'/'copy'/'paste' - срабатывают при вырезании/копировании/вставки. 
      Обеспечивают доступ к копируемым/вставляемым данным. 


//////////////
18.  Cookie
//////////////

#* Cookie
	= строки данных, обычно до 4 Мб
	- Хранятся у пользователя в браузере как отдельные файлы или в SQLite
	- Существуют заданное количество времени
	- Содержимое всегда доступно клиенту для просмотра
	- Общее количество куки на один домен ограничивается примерно 20
	- Являються частью HTTP протокола
	# Исп. для данных авторизации и аутентификации, корзины в магазине, настроек, трекинга, рекламы и т.д.
	# Пример: 
		> document.cookie = 'key=value; path=/; max-age=3600; samesite=lax; httpOnly; secure'

#* API
    - document.cookie 
    	#- Строка пар key=value разделенных ';'
    - document.cookie = "key=value"
    	#- Обновит значение по ключу key
        #- Строка 'key=value' не должна занимать больше 4Кб

#* Алгоритм использования cookie при аутентификации
    1. Запрос на сервер
    2. Сервер возвращает HTTP-заголовок Set-Cookie, 
    3. Браузер устанавливает куки с уникальным ID
    3. Запрос на сервер с HTTP-заголовком Cookie
    4. Сервер по куки определяет, кто сделал запрос

#* Cookie options
    - path 
		#- Абсолютный URL-префикс, для которого будут доступны куки
    - domain 
	 	#- Домен, которому доступны куки
		#- По умолчанию куки доступны домену, который их установил
    - expires
		#- Дата истечения срока действия куки
		#- Формат: 'Tue, 19 Jan 2038 03:14:07 GMT'
    - max-age
	 	#- Срок действия куки в секундах
		#- При значении '<= 0' куки удаляется
    - secure
		#- Ограничивает доступ к куки только по HTTPS
    - samesite
		#- Ограничивает доступ к куки исключительно доменом-владельцем
			> samesite=strict
				#/ Куки не отправляются при новом входе на сайт
			> samesite=lax
				#/ Работает так же как strict, но отправляет cookie если:
				#/ Используются безопасные HTTP-методы (например GET)
				#/ Осуществляется навигация на верхнем уровне
		#- Надежная защита от XSRF
    - httpOnly 
		#- При значении true куки могут изменятся только сервером
      

//////////////////////////////////////
19.  LocaleStorage & SessionStorage
//////////////////////////////////////

>> localeStorage/sessionStorage - объекты web-хранилища, хранят пары СТРОК ключ-значение:
      - НЕ отправляются на сервер при каждом запросе
      - минимум 5 Мб памяти для данных
      - сервер не может их использовать
      - привязаны к источнику (домен/протокол/порт)

>> Методы:
      1. setItem(key, value)  - сохранить ключ-значение
      2. getItem(key)         - получить значение по ключу
      3. removeItem(key)      - удалить значение по ключу
      4. clear()              - удалить все данные из объекта хранилища
      5. key(index)           - получить ключ по индексу
      6. length               - количество элементов в объекте хранилища

>> Особенности localStorage:
      - 1 объект на 1 источник (все его вкладки)
      - данные не имеют срока давности
      - данные не удаляются при презапуске браузера или ОС

>> Особенности sessionStorage:
      - 1 объект на 1 вкладку и iframes из того же источника
      - данные не удаляются при перезагрузке вкладки

>> Способы перебора ключей:
      1. Базовый цикл
      2. Object.keys(localeStorage)

>> Событие 'storage' - генерируется на всех вкладках (объекты window) источника кроме текущей.
      Срабатывает при вызове setItem, removeItem, clear.
      Свойства event: 
            1. key         - ключ, который обновился (null при вызове .clear())
            2. oldValue    - старое значение (null при первом добавлении ключа)
            3. newValue    - новое значение (null при удалении ключа)
            4. url         - url документа, где произошло обновление
            5. storageArea - объект хранилища, где произошло обновление.


///////////////////////
20.  Сетевые запросы
///////////////////////

#* HTTP/1
    - Исп. TCP
    - Одно TCP-соединение для каждного запроса
    - Заголовки НЕ сжимаются
       
#* HTTP/2
     - Исп. TCP + TSL
     - Одно TCP-соединение для множества запросов
     - Мультиплексирование
        #- Получение ответов одновременно с отправкой запросов (нет блокировки)
        #- Данные разбиваются на блоки (фреймы) по Stream ID
     - Заголовки сжимаются

>> AJAX (Asyncronous JavaScript and XML) - набор технологий, позволяющих работать с данными асинхронно,
      в т.ч. обмениваться данными с сервером без перезагрузки страницы.

>> REST - правила взаимодействия клиента и сервера:
    - Протокол HTTP/1
    - 1 запрос - 1 ответ
    - Серверу отправляется тип и адрес запроса
    - Каждый запрос содержит информацию о пользователе для идентификации
    - Кеширование

>> SOAP (Simple Object Access Protocol) - протокол обмена данными при помощи языка WSDL (основан на XML).
      > В качестве транспортного механизма исп. HTTP / FTP / SMTP.

>> CORS (Cross-Origin Resource Sharing) - механизм управления доступом к ресурсам домена-источника сторонним доменам 
      при помощи специальных HTTP-заголовков. 
      > Источники различаются по:
            - домену
            - порту
            - протоколу
      > Типы запросов CORS:
            - простые запросы (GET, POST, HEAD + Content-Type)
            - preflight

#* RPC (Remote Procedure Call - Удалённый Вызов Процедур)
      Способ взаимодействия между программами, позволяющий программе вызвать фу-ю в другом процессе (компьютере),
      как если бы она была в самой программе.
#!    Принцип работы:
            1. Клиент вызывает фу-ю, как если бы она была локально
            2. Вызов преобразуется в сетевой запрос
            3. Сервер принимает запрос и выполняет соответствующую фу-ю
            4. Результат отправляется клиенту
            5. Клиент получает результат

>> Preflight-запрос - предварительный запрос, который проверяет права доступа при обмене ресурсами со сторонним доменом.
>> Идемпотентный запрос - запрос, повторный вызов которого не изменяет состояние сервера (в т.ч. БД).

>> const controller = new AbortController() - объект для прерывания любых асинхронных запросов.
>> controller.abort() - генерирует событие 'abort' на объекте controller.signal, делает controller.signal.aborted === true.
>> fetch(url, { signal: controller.signal }) - теперь fetch отслеживает событие 'abort'.

#####################
*		Fetch
#####################

>> fetch(url, options) - отправляет сетевой запрос. Без options отправляет простой GET-запрос.
      options: {
            method: "GET", // Метод запроса
            headers: { },  // Заголовки
            body: undefined, // Тело запроса типа: "String", "FormData", "Blob", "BufferSource", "URLSearchParams"
            referrer: "about:client", // Заголовок Referrer в пределах текущего источника (url или "")
            referrerPolicy: "strict-origin-when-cross-origin", // Устанавливает правила для Referrer (см. табл.)
            mode: "cors", // Режим запроса на другой источник
            credentials: "same-origin", // Указывает отправлять ли cookie и auth-headers вместе с запросом
            cache: "default", // Настройка HTTP-кеширования
            redirect: "follow", // Позволяет стандартный редирект
            integrity: "", // Позволяет проверить соответствует ли ответ известной заранее контрольной сумме
            keepalive: false, // Позволяет браузеру выполнить запрос после того, как пользователь покинул страницу (window.onunload)
            signal: undefined, // AbortController
            window: window
      }
     
>> fetch возвращает объект класса Response со свойствами и методами:
      - Свойства:
            1. status   - код статуса HTTP-запроса
            2. ok       - true если status в диапазоне 200-299, иначе false
            3. body     - тело ответа (объект класса ReadableStream)
      - Методы:
            1. text()         - возвращает ответ как текст
            2. json()         - возвращает ответ как JSON
            3. formData()     - возвращает ответ как объект класса FormData
            4. blob()         - возвращает ответ как объект класса Blob
            5. arrayBuffer()  - возвращает ответ как объект класса ArrayBuffer 

########################
*		FormData
########################

> const formData = new FormData(form) - объект преобразованных данных HTML-формы в формат для отправки по сети.
      Данные отправляются всегда с заголовком 'Content-Type': 'multipart/form-data'.
> Методы formData:
      1. append(name, value)              - добавить поле
      2. append(name, blob, fileName)     - добавить поле типа <input type='file'>
      3. set(name, value)                 - как append, но удаляет поля с таким же именем
      4. set(name, blob, fileName)        - как append, но удаляет поля с таким же именем
      5. delete(name)                     - удалить поле с заданным именем
      6. get(name)                        - получить поле с заданным именем
      7. has(name)                        - проверить наличие поля с заданным именем

###################
*		URL
###################

> let url = new URL(url, [base]) - объект с методами и свойствами для удобного разбора URL.
      (url - путь, если указан base, иначе полный URL)
      (base - базовый адрес, к которому прибавится путь url)
> url.searchParams - перебираемый объект типа URLSearchParams с методами, которые кодируют не-латинские символы:
      .append(name, value) - добавить параметр
      .delete(name) - удалить параметр
      .get(name) - получить параметр
      .getAll(name) - получить все параметры с одинаковым именем
      .has(name) - проверить наличие параметра
      .set(name, value) - заменяет значение параметра и удаляет все одноименные параметры
      .sort() - отсортировать по имени

> Методы кодирования/декодирования спец. символов в строках:
      1. encodeURI / decodeURI - кодирует/декодирует символы запрещенные в URI. Исп. для целого URI.
      2. encodeURIComponent / decodeURIComponent - кодирует/декодирует символы запрещенные в URI 
      и символы (#, $, &, +, ,, /, :, ;, =, ?, @). Исп. для какой-то части от URI.

##############################
*		XMLHttpRequest
##############################

> let xhr = new XMLHttpRequest() - объект, который позволяет делать HTTP-запросы к серверу без перезагрузки страницы.

> Методы xhr: 
      .open(method, url, [async, user, password]) - конфигурирует запрос.
            (async - если указать false, то запрос будет синхронным (исп. редко))
            (user, password - логин и пароль для базовой HTTP-авторизации)
      .send([body]) - посылает запрос
      .abort() - отменяет запрос, генерирует событие 'abort', устанавливает xhr.status = 0
      .setRequestHeader(name, value) - устанавливает заголовок запроса. !!! Отменить невозможно. Повторные вызовы добавляют информацию
      .getResponseHeader(name) - возвращает значение заголовка ответа (кроме Set-Cookie и Set-Cookie2)
      .getAllResponseHeaders() - возвращает все заголовки ответа (кроме Set-Cookie и Set-Cookie2)

> Синхронный запрос - запрос, когда выполнение JS останавилвается на xhr.send() и возобновляется после получения ответа (исп. редко).

> События для получения ответа:
      1. load - когда получен какой-либо ответ, включая ответы с HTTP-ошибкой (404)
      2. error - когда запрос не может быть выполнен (невалидный URL)
      3. progress - периодически во время загрузки ответа от сервера, сообщает о прогрессе (event.loaded, event.total)
      4. timeout -  когда вышло время отведённое на загрузку
      5. abort - когда запрос прерван

> Свойства xhr:
      1. status - код состояния HTTP (200)
      2. statusText - сообщение о состоянии HTTP-ответа
      3. response - тело ответа
      4. timeout - время, которое мы готовы ждать ответ (в миллисекундах)
      5. responseType - указывает ожидаемый тип ответа: 'text', 'json', 'arraybuffer', 'blob', 'document'
      6. readyState - код состояния запроса: 0 - unsent, 1 - opened, 2 - header received, 3 - loading, 4 - done
      7. upload - объект, который генерирует события для отслеживания отправки данных на сервер:
            loadstart, progress, abort, error, load, timeout, loadend (все аналогичны событиям xhr)
      8. withCredentials - если установить в true, то при запросе на другой источник (origin) отправлять также cookie и auth-headers

>> Способы поддерживать постоянное соединение с сервером:
      1. Частые опросы (Polling) - регулярный запрос (например раз в 10 секунд)
      2. Длинные опросы (Long Polling):
            запрос > ответ сервера только когда есть сообщения > незамедлительно новый запрос
      3. WebSocket
      4. EventSource

#########################
*		WebSocket
#########################

>> WebSocket - протокол, предоставляющий возможность обмениваться данными между браузером и сервером 
      через постоянное соединение, то есть без разрыва соединения и дополнительных HTTP-запросов.

> let socket = new WebSocket('wss://example.info') - установить соединение, отправить заголовки.
> socket.send(data) - отправить текстовые или бинарные данные(Blob, ArrayBuffer).
> socket.binaryType - формат бинарных данных (по умолчанию Blob).
> socket.bufferAmount - количество буферизированных данных ожидающих отправки по сети (очередь).
> socket.close([code], [reason]) - закрыть подключение [с кодом и причиной].
> socket.readyState - код состояния соединения: 0 - подключение
                                                1 - подключено (обмен данными)
                                                2 - закрытие соединения
                                                3 - соединение закрыто                        
> События socket: open, message, error, close.
> Браузер отправляет спец. заголовки на сервер, чтобы проверить поддерживает ли он WebSocket. Положительный ответ 101.
> Передача данных делится на фрагменты (frames).

###########################
*		EventSource
###########################

> let eventSource = new EventSource(url, [{ withCredentials: true }]) - создаёт постоянное соединение с сервером
      и слушает его события (Server Sent Events).
> eventSource.lastEventId - id последнего обработанного события 'message'.
> eventSource.readyState - код состояния соединения: 0 - подключение или переподключение
                                                     1 - подключено
                                                     2 - подключение закрыто
> Свойства:
      - данные посылает только сервер
      - только строчный тип данных (чаще всего исп. JSON)
      - протокол соединения HTTP
      - при обрыве соединения автоматически переподключается

> Типы событий: 'message', 'open', 'error', кастомные события.
> Принцип работы сервера:
      1. Сервер передаёт строку с обязательным полем data и необязательными полями id, event, retry
      2. Поля разделяются через \n
      3. Поле id - записывается в eventSource.lastEventId и при переподключении браузер отправляет на сервер 
            заголовок Last-Event-ID со значением id  для возобновления передачи данных начиная с сообщения с таким id
      4. Поле event - кастомное событие
      5. Поле retry - время в миллисекундах, спустя которое будет попытка переподключения к серверу

> Пример передаваемой строки: 'retry: 15000\nevent: customEvent\ndata: someData\nid: 1\n\n'.

################################
*		Protocol Buffers
################################

    = механизм сериализации данных:
    	1. Данные преобразуются в бинарный формат
        2. Затем с помощью библиотеки нужного языка, данные преобразуются в формат этого языка

#* Сериализация данных
    = преобразование данных в пригодный для передачи по сети формат.

#* Типы данных
     1. Примитивные (скалярные): https://protobuf.dev/programming-guides/proto3/#scalar
     2. Совтавные: message, enum, repeated, map, oneof

#* Составные типы
    + Порядок полей неважен
    + Необходимо присвоить полю уникальный номер (1 - 536 870 911)
    + Номера 19 000 - 19 999 зарезервированны

#* Параметры файла (option)
    optimize_for = SPEED; - режим опитимизации де/сериализации данных (скорость | размер | функционал)
    retain_unknown_fields = true; - режим сохранения Unknown fields (по умолчанию)

#* message
    # Аналог interface в TS
    + Все поля необязательны (но можно указать явно optional)
    + Параметры поля:
    	#- optional - явно устанавливает опциональность поля
    	#- reserved - резервирует номера или строчные имена полей
        	# reserved 2, 10, 1 to 5, 20 to max
        #- repeated - устанавливает поле как однотипный массив
    + Номера 1 - 15 исп. 1 байт для кодирования (следует исп. для частоисп. полей)
    + Номера 16 - 2 047 исп. 2 байта для кодирования

#* map<K, V>
    = устанавливает поле как ассоциативный массив
    	# K - любой примитивный тип, кроме float, double, bytes, enum
    	# V - любой тип, кроме map
    + Не может исп. repeated, optional
    + Альтернатива (обратная совместимость):
    	message MapFieldEntry {
        	key_type key = 1;
            	value_type value = 2;
		}
        repeated MapFieldEntry map_field = N;
            
#* oneof
    + Можно передавать любой тип, кроме map и repeated
    + Нельзя исп. reserved, optional
    + На клиенте можно узнать какое значение поля было установлено (WhichOneof)

#* enum
    + Настоятельно рекомендуется чтобы
    	#- Первое поле имело номер 0
    	#- Первое поле называлось по типу ENUM_TYPE_NAME_UNSPECIFIED/_UNKNOWN
    + option
    	allow_alias = true 
			# Разрешает задавать другое имя с тем же номером

#* package
    = исп. для избежания конфликта имён, при нескольких .proto-файлах с одинаковыми message-именами
    	# package myProject.packageName;

#* Unknown fields
    = поля, которые клиент не смог разпарсить при десериализации
    + Сохраняются в бинарном виде

#* Прочие сведения
    > Пустые поля не сериализуются.
    > import public "foo.proto"; - содержимое этого импорта БУДЕТ видно импортёрам текущего файла
    > google.protobuf.Any - тип Any (из import "google/protobuf/any.proto";)

#* Best Practices
    + НЕ переисп. номера полей (теги)
    + НЕ изменять тип поля (в т.ч. с repeated на примитивный)
    + НЕ делать message большим (более 100 полей)
    + НЕ изменять значение поля по умолчанию
    + НЕ исп. текстовый формат данных
    + НЕ исп. ключевые слова языка для имён полей
    + Резервировать номера и имена удалённых полей или удалённых enum-значений
    + Записывать новые или переименованые enum-поля конец
    + Исп. ENUM_TYPE_NAME_UNSPECIFIED = 0
    + Исп. типы: #@ https://protobuf.dev/best-practices/dos-donts/#well-known-common
    + Один message на .proto-файл: #@ https://protobuf.dev/best-practices/1-1-1/
    + Исп. РАЗНЫЕ message-имена для RPC и хранилищ (БД, кеш, queue)
    #! Убрать резервирование можно тогда, когда все клиенты и серверы перешли на новую версию поля


///////////////////////
21.  iframe и window
///////////////////////

>> window.open(url, name, params) - открывает окно pop-up (новый window), возвращает ссылку на это окно.
      > window.opener - ссылка на открывающее его окно.

>> window.postMessage(data, target) - отправляет data в target, вызывает событие 'message' в target.

>> Критерии одинакового источника (полного доступа):
      - протокол
      - домен
      - порт


//////////////////////////////
22.  Бинарные данные, файлы
//////////////////////////////

>> new ArrayBuffer(16) - ссылка на непрерывную область в памяти фиксированной длины 16 байт заполненной нулями.

>> TypedArray - скрытый класс типизированных подклассов для представление бинарных данных класса ArrayBuffer.
      > new Uint8Array(8).__proto__.__proto__ === TypedArrayPrototype
      > new Uint8Array(8).__proto__.__proto__.constructor.name === TypedArray

> Подклассы TypedArray:
      1. Int8Array, Int16Array, Int32Array - могут содержать знаковые целые 8, 16, 32-битные числа.
      2. UInt8Array, UInt16Array, UInt32Array - могут содержать беззнаковые целые 8, 16, 32-битные числа.
      3. Float32Array, Float64Array - могут содержать числа с плавающей точкой 32, 64-бит. 
      4. Uint8ClampedArray - могут содержать беззнаковые целые 8-битные числа, 
            которые обрезаются по верхней и нижней границе при присвоении (0-255).
      
> Способы создать TypedArray:
      1. new TypedArray(buffer, [byteOffset], [length]), 
      2. new TypedArray(object)
      3. new TypedArray(typedArray)
      4. new TypedArray(length)
      5. new TypedArray()
!!! Во всех случаях, кроме 1. автоматически создаётся объект типа ArrayBuffer.

> typedArray[i] - i-тый элемент массива.
> typedArray.buffer - ссылка на объект типа ArrayBuffer.
> typedArray.byteLength - размер содержимого в байтах.
> typedArray.set(fromTypedArray, [offset]) - копирует все элементы из fromTypedArray в typedArray начиная с позиции offset.
> typedArray.subarray([begin, end]) - возварщает новый typedArray начиная с позиции begin до end (НЕ-включительно).

> Нельзя удалять элементы из TypedArray.
> При запредельных значениях старшие биты (слева) будут отброшены.
> TypedArray имеет те же методы, что и Array, кроме 'splice' и 'concat'.

>> new DataView(buffer, [byteOffset], [byteLength]) - НЕ-типизированное представление бинарных данных класса ArrayBuffer.
      > Свойства dataView: buffer, byteLength, byteOffset 
      > Методы для работы с данными: getInt8(), setInt8(), getFloat32(), setFloat32() и т.д.

>> new TextDecoder([encoding], [options]) - позволяет декодировать бинарный буфер в строку.
      encoding = кодировка, по умолчанию 'utf-8'
      options = {       
            fatal: если true, то генерируется ошибка при невалидных данных 
            ignoreBOM: если true, то игнорируется признак BOM 
      }
> textDecoder.decode([input], [options]) - возращает строку декодированную из бинарного буфера.
      input = бинарный буфер (BufferSource)
      options = { stream: если true, то непрерывно декодирует поток данных }

> new TextEncoder() - позволяет закодировать строку в бинарный массив.
      > textEncoder.encode(str) - возвращает бинарный массив Uint8Array закодированной строки str.
      > textEncoder.encodeInto(str, destination) - кодирует str и помещает в destination, который должен быть Uint8Array.

>> for await ... of - проходит через асинхронные итерируемые объекты, вызывая Symbol.asyncIterator.
!!!   for await ... of              |     ReadableStreamDefaultReader.read()
      1. Высокоуровневый            |     1. Низкоуровневый
      2. Авторазблокировка потока   |     2. Ручная разблокировка 
      3. Автозавершение чтения      |     3. Ручное завершение чтения 
      4. -                          |     4. Возможность управлять чтением в зависимости от условий (паузы)

>> Blob (Binary Large Object) - объект предоставляющий API для работы с неизменяемыми бинарными данными.
      > Он может содержать текст, изображения, аудио, видео и пр. данные. 
      > Класс File наследует от Blob.


////////////////////
23.  Тестирование
////////////////////

>> Цели автотестирования:
      1. Написание сценария, по которому фу-я должна работать.
      2. Проверка соответствия ПО предъявляемым требованиям.

>> Регрессионное тестирование - проверка целосности старого кода, после внесения новых изменений.

>> Функциональное тестирование:
      > UNIT - тест отдельной фу-и.
      > INTEGRATION - взаимодействие нескольких фу-й.
      > E2E (end-to-end) - полная функциональность частей приложения (регистрация, авторизация, оплата).
      > Скриншотные тесты - сравнение старой и новой визуальной части (UI).

>> Правила подбора данных для тестирования:
      1. Тест на коррекные значения
      2. Тест на пограничные значения
      3. Тест на все диапазоны некорректных значений


/////////////
24.  Графы
/////////////

>> Граф - система состоящая из множества узлов (вершин) соединённых ребрами.
      > G = (X, A), где X - количество вершин, A  - количество рёбер.

>> Неориентированный граф (граф) - направленность рёбер между вершинами может быть в любом направлении.
>> Ориентированный граф (орграф) - направленность рёбер (дуг) между вершинами может быть только в одном направлении,
      то есть одна вершина является начальной, а другая - конечной.

>> Инцидентность - совместное свойство пары вершина + ребро, обозначающее соединены ли они друг с другом.
>> Смежность - свойство 2-х вершин (2-х рёбер), обозначающее наличие общего ребра (вершины), 
      посредством которого они соединены.

>> Степень вершины - количество рёбер, инцидентных этой вершине (соединённых с этой вершиной). 
      По чётности количества рёбер вершины называют чётными и нечётными.

>> Одно ненаправленное ребро можно заменить двумя направленными дугами (A - B ~ A ⇆ B).
>> Кратные рёбра - два ребра между двумя вершинами.
>> Мультиграф - граф, содержащий кратные рёбра.
>> Петля - ребро, начинающееся и заканчивающееся в одной вершине.
>> Псевдограф - граф, содержащий кратные рёбра и петли.

>> Для передачи информации о графах используются матрицы:
      1. Смежные вершины обозначаются 1, несмежные 0.
      2. Рёбра могут содержать значения (вес) в отдельной матрице.

>> Смежные виды Графов и (Орграфов):
      1. Маршрут (Путь) - последовательность смежных рёбер (дуг), которые могут повторятся.
      2. Цикл (Контур) -  последовательность, начальная вершина которой совпадает с конечной.
      3. Цепь (Простой путь) - последовательность, в которой нет повторений рёбер (дуг), но могут быть повторения вершин.
      4. Простая цепь (Элементарный путь) - последовательность, не допускающая повторений вершин.


//////////////////////////////////////
25.  Авторизация и аутентификация
//////////////////////////////////////

#* Аутентификация
	= проверка подлинности пользователя (устройства)

#* Авторизация
    = проверка и предоставление прав пользователя на доступ к конкретным ресурсам или функциям приложения
	- RBCA (Role-Based Access-Control)
		#/ Фильтрация доступов по ролям
	- Claims-based
	  	#/ Прямое указание доступов

###################
*		JWT
###################

#* JWT (JsonWebToken)
    # Схема алгоритма на Miro
    = зашифованные JSON-данные в виде строки "header.payload.signature"
        #- header - описание алгоритма шифрования (JSON)
        #- payload - передаваемые данные (JSON)
        #- signature - уникальная строка-"подпись" (header + payload + secret) 
        	#! secret - знает только сервер
    - Исп. для аутентификации
        #- Проверка валидности токена
    - Исп. для авторизации
        #- payload может содержать данные о правах пользователя (роль)
    - Access token:
        #- Исп. для доступа к данным, для которых нужна авторизация
        #- Хранится в LocaleStorage
        #- Малый срок жизни (чем меньше, тем безопаснее, обычно 15 мин)
    - Refresh token:
        #- Исп. для обновления пары токенов Access-Refresh
        #- Хранится в куках
        #- Большой срок жизни (дни-года)

#####################
*		OAuth
#####################

#* OAuth 2.0 (Open Authorization)
    # Схема алгоритма на Miro
    = протокол авторизации
    - Позволяет приложению получать ограниченный доступ к данным пользователя в другом приложении
	- Стороны:
	  	#- Клиент
	  		# Приложение, которое запрашивает доступ к данным
		#- Сервер
	  		# Приложение, которое аутентифицирует пользователя и выдаёт токен
			# Хранит защищённые данные
	- Авторизационные данные:
	  	#- response_type
	  		# Тип ответа сервера
			# Обычно = code, который клиент обменяет на токен
		#- client_id
	  		# Выдаёт провайдер (самописный или например Google) зарегистрации у него приложения
	  	#- redirect_uri
	  		# Адрес редиректа пользователя после успешной ответа
		#- scope
	  		# Список предоставляемых прав
		#- state
	  		# CSRF-токен
		#- grant_type
	  		# = authorization_code
	  			#/ В запросе на авторизацию
			# = refresh_token
	  			#/ В запросе на обновление токенов
		#- code

#* OpenID Connect (OIDC)
    = протокол аутентификации (технология SSO)
    - Позволяет авторизоваться в приложении использую учётную запись пользователя в другом приложении
      
#* 2FA (Двухфакторная аутентификация)
    = тип аутентификации, при которой для подтверждения используется 2 каких-либо способа
        # Например пароль + биометрия
    - Виды факторов:
        1. OTP (One Time Password) - одноразовый пароль
            # TOTP (Time-based) - код, который валидый короткое время (например 30 сек)
            # HOTP (HMAC-based) - код, обновляющийся при каждом новом запросе
        2. Физический ключ
            # Yubikey - аппаратный ключ безопасности (FIDO2/U2F, TOTP, HOTP)
        3. Passkeys (ключи доступа)
            # Face ID / Touch ID
            # Google Password Manager
        4. Email / SMS


-----------------------------------
* * * Библиотеки и Фреймворки * * *
-----------------------------------

#* cross-env
	= позволяет запускать скрипты, которые используют и устанавливают переменные окружения
#* dotenv
	= позволяет загружать переменные окружения в process.env из файла .env
#* nodemon
	= автоматически перезапускает сервер после изменений в файлах папки проекта
#* cookie
	= удобный парсинг куки
#* cookie-parser
	= удобный парсинг куки 
	# express middleware
#* express-session
	= удобная работа с сессиями
	# express middleware


////////////
1.   Jest  
////////////

#* Jest
	= фреймворк для тестирования

#* Expect-методы
	= сопоставляют фактический результат и ожидаемый
#* Mock
	= фу-я/данные заменяющие фу-ю/данные, которые исп. в тестируемой фу-и
	- Mock-функции:
    	#- Перехватывают вызовы
    	#- Устанавливают возращаемое значение
    	#- Изменяют реализацию

> mockFn.mockReturnValue(value)
	= возвращает value при каждом вызове mockFn
> jest.mock(module)
	= автоматически устанавливает все экспорты module в mock-функцию.
> spyOn(obj, 'method')
	= mock одного указанного 'метода'.


////////////
2.   Node
////////////

#* NodeJS
	= фреймворк
	- Cреда выполнения JavaScript-кода
    - NodeJS = V8 + LibUV
    - Позволяет выполнять JS вне веб-браузера
    - Предназначен для создания серверных приложений
    - Хорошо подходит для обработки потоковых данных в реальном времени
    - НЕ подходит для решения задач, требующих много ресурсов     

#* Демультиплексор событий
	= собирает и ставит в очередь события I/O
#* C++ Bindings
	= группа библиотек, которые позволяют использовать в NodeJS функционал библиотеки LibUV
#* Node REPL
	= интерактивный интерпретатор (Read-Evaluate-Print-Loop).    
#* Thread Scheduler
	# Схема неблокирующего I/O на Miro
	= планировщик потоков, то есть часть ОС, которая отвечает за паралельное выполнение задач

#* Принцип работы шаблона REACTOR
    1. Приложение[I/O <--> Обработка] <---┐
	2. Демультиплексор событий 			  |
	3. Очередь событий 					  |
	4.  Event Loop -----------------------┴

#* LibUV
	= библиотека на C, которая управляет потоками и обеспечивает неблокирующий кроссплатформенный I/O
	- LibUV = Event Loop + Thread Pool
    	#- Thread Pool
			#/ По умолчанию 4 threads
        	#/ Максимум 1024 threads

#* Этапы выполнения событий в Event Loop
    1. process.nextTick (метод, который вызывает любой callback немедленно, независимо от этапа Event Loop)
    2. Promise
    3. Timers (setTimeout, setInterval)
    4. Pending (Input/Output callbacks отложенные до след. итерации Event Loop)
    5. Idle, Prepare (внутренние служебные задачи NodeJS)
    6. Poll (Event Loop получает и выполняет задачи Input/Output)
    7. Check (setImmediate)
    8. Close (close event callbacks)
    9. Продолжать ли Event Loop? (если нет, то выход из цикла)

#* Этапы выполнения событий в Event Loop
	# Упрощённая схема
    1. process.nextTick <---┐
    2. Promise              |
    3. Timers               |
    4. I/O Events           |  
    5. Check                |
    6. Close ---------------┴---> Выход из Event Loop

#* Свойства CommonJS-модулей
	- Импорт/экспорт:  	
		> const fsPromises = require('fs/promises')
		> module.exports.foo = foo
		> module.exports.foo = function () {}
		> module.exports = function () {}
			# Экспорт по умолчанию
	- Внутреннее устройство CommonJS-модуля:
    	(function (exports, require, module, __filename, __dirname) {
        	console.log(arguments.callee.toString())
      	})

#* Свойства ES-модулей (2025)
	- Импорт встроенных node-модулей:
		> import fsPromises from 'node:fs/promises'
	- await можно исп. без async
	- Встроенный fetch (в т.ч. AbortController)

#* EventEmitter
	= класс, который исп. для регистрации и генерации событий
    	> const eventEmitter = new EventEmitter()
      	> eventEmitter.on(eventName, handler)
      	> eventEmitter.emit(eventName, arg1, ...)
			# Запуск события с передачей списка аргументов в handler

#* Middleware
    = набор фу-й, которые выполняются поочередно
    - В express:
        > app.use( (req, res, next) => { next() } )
            # next() - вызывает след. middleware-функцию
            # Конечный обработчие (app.get, app.post и т.п.) не должен вызывать next()

#* Buffer
	= класс, который исп. для представления последовательности байтов фиксированной длинны
    - Наследует класс Uint8Array
    - Buffer.concat(bufArr, length)
		#- Возвращает новый Buffer, который является объединением элементов bufArr

#* Поток (Stream)
    = массив данных
    - Предоставляет поочерёдный доступ к чтению/записи частей данных (chunk), то есть до полной их загрузки
    - Хранит информацию о том, сколько данных было прочитано/записано
    - Типы потоков:
        #- Readable
        #- Writable
        #- Duplex 
    		# Readable + Writable = два независимых дргу от друга потока
        #- Transform 
        	# Как Duplex, но даныые из Readable автоматически добавляются в Writable)
    - Типы управления потоком:
    	#- Автоматический (NodeJS)
    	#- Ручной (RxJS)
    - Stream является экземплярами EventEmitter
    	> fs.createWriteStream(path)  #/ возвращает поток для записи
    	> fs.createReadStream(path)   #/ возвращает поток для чтения
    - По умолчанию размер каждого фрагмента === 64 kB.

#* Readable Stream
    - Методы:
    	> resume()
        	# Продолжить чтение 
        	# Вызов метода без обработки данных приведёт к их потере
        > pause()
        	# Приостановить чтение
        > pipe()
        	# Читает данные из одного потока и сразу записывает в другой
			# readableStream.pipe(writableStream1).pipe(writableStream2)
    - События #-: data, resume, pause, close, end, error

#* Writable Stream
    - Методы:
        > write(data, encoding, cb)
            # Записывает данные в поток
            # Возвращает true или false
            # вызывает cb 
        > end(data, encoding, cb)
            # Как write(), но генерирует событие 'finish' - сигнал завершения записи
            # Закрывает поток при autoClose: true   
    - События #-: drain, finish, close, error  

#* Модули
	# Это встроенные переиспользуемые блоки кода
    - process
		#/ Предоставляет информацию о текущем процессе NodeJS и контроль над ним
    - path
		#/ Предоставляет API для работы с путями
    - fs
		#/ Предоставляет API для взаимодействия с файловой системой
    - os
		#/ Предоставляет API для взаимодействия с ОС
    - cluster
		#/ Позволяет исп. многоядерность, то есть запускать несколько процессов
    - events
		#/ Позволяет работать с событиями 
		#/ Обработчики вызываются в порядке их добавления и СИНХРОННО
    - stream
		#/ Позволяет работать с потоками
		#/ Позволяет создавать кастомные типы потоков
		- stream/promises
			#/ Предоставляет альтернативный набор асинхронных фу-й для работы с потоками
			#/ Фу-и возвращают Promise
    - http
		#/ Позволяет передавать/получать данные по протоколу HTTP:
	- worker_threads
		#/ Позволяет управлять потоками из кода
	- test
		#/ Предоставляет API для тестирования
		#/ Руководство: 
			> https://nodejsdev.ru/guides/nodejs-test-runner/
	- url
		#/ Предоставляет API для работы с URL (разбор, форматирование, преобразование)
	- perf_hooks
		#/ Предоставляет API для измерения производительности

#* Методы
	- http
		> http.createServer((req, res) => { res.end() })
			# req - readable stream
			# res - writable stream
			#! Метод res.end() НЕОБХОДИМО вызывать в каждом ответе, чтобы вернуть контроль браузеру

	- stream/promises
		> pipeline(source[, ...transforms], destination[, options])
			#- Последовательно читает-записывает потоки transforms начиная с потока source
			#- Результат каждого потока становится входными данными для следующего
			#- Окончательный результат будет записан в поток destination
			#- Автообработка ошибок: если в каком-либо потоке ошибка, то все потоки корректно закрываются
			#- Автоматическое закрытие потоков
			#- Возвращает Promise (можно исп. await)	

	- url
		> fileURLToPath(url)
			#- Преобразует файловый URL в путь понятный для конкретной ОС
				# file:///home/user/file преобразуется в /home/user/file
			#- Декодирует URL-спец.символы
			#- Противоположный методу pathToFileURL(url)

#* CLI команды node
	--watch
		- автоматически перезапускает приложение при изменении файлов
	--env-file=.env
		- загружает переменные окружения из файла .env

*           Криптография

#* Хеширование
    = 
#* Шифрование
    = 

#* HMAC (Hash-based Message Authentication Code)
    = алгоритм шифрования сообшения с помощью ключа и HASH-функции
    - Hmac = класс реализующий этот алгоритм (расширяет stream.Transform)
    - Методы:
		# Создаёт hmac (поток Transform)
        createHmac(alg, key)
        	# Добавляет данные для шифрования
			.update(data)
			# Вычисляет шифр в Buffer или строку (при указанной кодировке)
        	.digist([кодировка])


////////////
3.   Vite
////////////

>> Vite - инструмент сборки web-приложений.

>> Основные части:
      1. Dependencies (зависимости) - в основном native JS, редко изменяется.
      2. Source code (исходный код) - постоянно редактируемый код.

>> Основные инструменты:
      1. Dev-сервер
      2. Build-команды


/////////////
4.   React
/////////////

>> React - JS-библиотека для построения интерактивного UI.
>> React Native - фреймворк для разработки Android и IOS приложений.

>> Этапы отрисовки компонента:
      1. Триггер render
            - начальный render (createRoot --> root.render)
            - re-render (обновление состояния)
      2. render
      3. Фиксация в DOM

>> События-пропсы с окончанием 'Capture' (например onClickCapture) обрабатываются на этапе погружения.  
>> Reconciliation (согласование, урегулирование, сверка) - механизм сравнения деревьев. Правила сравнения:
      - элементы сравниваются последовательно (сверху вниз)
      - при смене типа (тега) элемента он перемонтируется
      - при указанном key элемент перемонтируется только при смене типа (предыдущее правило)

########################
*		useState
########################

>> Свойства useState(initValue):
      1. render только после изменения состояния (изменение примитива или ссылки)
      2. Фу-я изменения состояния (set) работает асинхронно 
      3. При useState(callback) в callback передается как аргумент предыдущее состояние
      4. Возможность передавать фу-ю возвращающую initValue. 
            С целью оптимизации лучше всего передавать callback, вызов которого вернет результат вызова фу-и,
            чтобы рендерить только после внесения всех состояний в фу-и.

>> Состояние можно обновлять любое количество раз, но оно не изменится до след. рендера:
      - setValue(value)    --> заменить состояние
      - setValue(callback) --> добавить callback в очередь на render 
            (callback принимает текущее состояние и возвращает следуюющее)

>> Изменение состояния объектов и массивов:
      - устанавливать копию с нужными изменениями (..., map, filter, concat, slice)
      - вложенные объекты и массивы также необходимо копировать
      - лучше всего использовать библиотеку Immer  

>> key - уникальный только в родительской ОВ, глобальная ОВ доступа к нему не имеет.

>> Способы сбросить состояния компонента до начального значения:
      1. Удалить, затем добавить компонент.
!!!         Наиболее распостранненным решением является "поднятие состояния" в родительский компонент,
            чтобы сохранить состояния независимо от наличия компонента в DOM-дереве.
      2. Передать key. При каждом изменении key React ре-рендерит один и тот же компонент, 
            но состояния соответсвуют своему key.
!!!         Состояния необходимо сохранять вне компонента, например в localStorage.

##########################
*		useReducer
##########################

>> const [state, dispatch] = useReducer(reducer, initArg, init):
      -> state - текущее состояние
            --> после 1-го рендера state === initArg или === init(initArg) 
      -> dispatch - фу-я, вызов которой позволяет обновить state и вызвать ре-рендер
            --> принимает 1 аругумент - action (обычно объект со свойством type)
            --> action добавляется в очередь
            --> ре-рендера не будет, если Object.is( currentState, nextState ) === true
            --> ре-рендер будет только после срабатывания ВСЕХ обработчиков dispatch вызванного события
      -> reducer - фу-я, в которой обновляется state
            --> принимает 2 аргумента: (state, action)
            --> возварщает следующий state
      -> initArg - начальное значение state, или значение, на основе которого оно вычисляется в фу-и init
      -> init - опциональная фу-я, которая возвращает начальное state вычисленное на основе initArg

>> useReducer добавляет action в очередь

##########################
*		useContext
##########################

>> createContext и useContext служат для передачи данных от род. комп. к глубоко вложенным доч. комп., 
      которые исп. передаваемые данные, минуя при этом доч. комп., которые не используют передаваемые данные.

>> createContext(defaultValue):
    1. Возвращает компонент-контекст.
    2. defaultValue нельзя изменить. useContext возвращает это значение в одном случае: 
            - нет провайдера-родителя выше по иерархии
    3. Пропс value компонента NameContext.Provider передает любое значение доч. компонентам, 
            которые используют useContext(NameContext).
    4. Многоразовым вызовом NameContext.Provider можно перезаписывать значение value.

>> useContext(NameContext):
    1. Возвращает значение, котороле было передано в пропс value компонента NameContext.Provider,
            или defaultValue, если не найден такой компонент выше по иерархии.
    2. NameContext.Provider должен быть родительским комп. по отношению к комп., 
            которые будут использовать useContext.

>> Рекомендации по использованию useContext:
    1. Переписать приложение с использованием useContext, когда количество передаваемых пропсов приближается к 10.
    2. Создавать отдельный файл, из которого будут экспортироваться useContext's.
    3. Комбинировать useContext и useReducer в одном файле:
        3.1. createContext
        3.2. export NameProvider > useReducer > return Providers chain > children
        3.3. declare nameReducer
        3.4. export custom hooks (return useContext)

######################
*		useRef
######################

>> useRef используется: 
      - для хранения данных не зависящих от рендера
      - для получения доступа к DOM-элементам

>> useRef(initValue) - возвращает объект со свойством current.
      Вызывается только один раз - во время инициализирующего рендера компонента.

>> Обычно initValue устанавливают в null, затем изменяют current, так как current === initValue на каждом,
      рендере пока current не будет изменено.

>> Свойство current: 
      - можно менять
      - при изменении не вызывает ре-рендер
      - записывать и читать нужно в useEffect и обработчиках событий, а не во время рендера
      - при передаче объекта в атрибут ref JSX-элемента, свойство current будет содержать ссылку на этот элемент

#########################
*		useEffect
#########################

>> useEffect(setup, dependencies) - позволяет синхронизировать компонент с внешними системами.
      -> setup - callback, который вызывается при срабатывании эффекта.
            --> может вернуть cleanup-callback, который выполнит очистку.
            --> при ре-рендере компонента вызывает cleanup со старыми значениями, затем setup с новыми
            --> при удалении компонента из DOM вызывает cleanup 
      -> dependencies - опциональный массив значений:
            --> при его отсутствии - эффект срабатывает при каждом рендере компонента
            --> при пустом массиве [] - эффект срабатывает единожды: при инициализирующем рендере
            --> при наличии значений в массиве - эффект срабатывает после каждого изменения какого-либо из значений

>> Момент срабатывания useEffect: 
      Рендер - Обновление экрана - useEffect.
>> Момент срабатывания useLayoutEffect:
      Рендер - useLayoutEffect - Обновление экрана
>> useMemo - хук для мемоизации сложных вычислений между ре-рендерами.
>> useCallback - хук для сохранения ссылки на фу-ю между ре-рендерами.
>> useFormStatus - хук, который предоставляет инфо о статусе отправки формы.


////////////
5.   Next
////////////

>> Next.js - фреймворк React для создания клиентских приложений с участием серверного рендеринга. 

>> Способы навигации:
      - Link (рекомендованный)
      - useRouter (клиентские компоненты)
      - redirect (серверные компоненты)
      - History API

>> Стратегии рендеринга:
      - Client Side Rendering (CSR)
      - Static Site Generation (SSG)
      - Server Sider Rendering (SSR)
      - Incremental Static Regeneration (ISR)

!!! По умолчанию Next использует SSR или SSG.

>> CSR - стратегия рендеринга, когда вся работа выполняется на стороне клинета (в браузере).
> Принцип работы CSR: 
      1. Запрос на сервер (открытие сайта)
      2. Загрузка index.html содержащий <div id="root"> и <script> (React-приложение)
      3. Загрузка <script> 
      4. ReactDOM встраивает React-приложение в <div id="root">
      5. API-запрос данных
      6. Отображение данных на странице
    
>> SSG - стратегия рендеринга, когда сервер отправляет на клиент (в браузер) готовую статическую страницу, 
      при этом API-запросы выполняются во время сборки приложения (build).

>> SSR - стратегия рендеринга, когда сервер отправляет на клиент (в браузер) готовую интерактивную страницу.
> Этапы SSR:
      1. Запрос данных у сервера (при первом входе пользователя на сайт)
      2. Рендеринг HTML на сервере
            - React преобразует Server Components в спец.формат данных RSC Payload, ссылающийся на Client Components
            - Next использует инструкции JS в RSC Payload и Client Components, чтобы отрисовать HTML на сервере в соответствии с указанным роутом
      3. Отправка HTML, CSS, JS клиенту
      4. Отображение НЕинтерактивного UI (HTML, CSS) по указанному роуту
      5. Используя RSC Payload, Next сверяет клиентские и серверные деревья, обновляет DOM
      6. Гидратация UI (встраивание интерактивности на страницу)
      7. При переходе между страницами работает CSR

>> ISR - стратегия рендеринга, когда статически сгенерированные сервером страницы (SSG) ререндерятся по триггеру.

>> React Server Component Payload (RSC) - бинарное представление React Server Components. 
      Используется для обновления браузерного DOM.
      > Содержит:
            - преобразованный результат Server Components
            - placeholders для Client Components и ссылки на их JS
            - пропсы передаваемые из Server Components в Client Components

>> Hydration (гидратация) - процесс подключения обработчиков событий к DOM, чтобы сделать статический HTML интерактивным.
>> Streaming - процесс разделения HTML на небольшие части (chunks), 
      например React-компоненты, и отправки их клиенту по отдельности.

>> Иерархия рендеринга спец.компонентов: layout -> template -> error -> loading -> not-found -> page

>> Отличие template от layout в том, что template создает новый экземпляр шаблона для каждого дочернег элемента,
      соответственно сбрасываются состояния и эффекты.

>> new Image() - расширяет и оптисизирует нативный Image.
      > width и height в компоненте Image исп. для определения соотношения сторон, 
            но не определяют размер самого изображения.


////////////////////
6.   TypeScript
////////////////////

>> Тип данных - множество значений и методы, которые могут быть выполнены над этими данными.
      > Значимый тип - хранит значение.
      > Ссылочный тип - хранит ссылку на значение.

>> Этапы обработки кода компилятором (называют их Лек-Син-Сем):
      1. Лексический анализ (tokenizing) - разделение исходного кода на отдельные допустимые последовательности
            символов, удаление пробелов и комментариев (let, n, =, 1, +, 2, *, 3, ;).
      2. Синтаксический анализ (parsing) - определение последовательности выполнения функций
            в соответствии с их приоритетом (let, *, +, =).
      3. Семантический анализ - проверка конструкций на соответствие типам и логике, выполняет связывание.

>> Связывание - прикрепление типа данных к операндам.
>> Типизация - связывание выражения с типом данных.
>> Вывод типов (type inference) - свойство компилятора определять тип данных выражения.

>> Свойства типизации:
      > Статическая - типизация, при которой связь типа данных и выражения не может быть изменина.
      > Динамическая - типизация, при которой связь типа данных и выражения может быть изменина.
      > Сильная (strongly) - возможность только явного преобразования типов.
      > Слабая (weakly) - наличие НЕявного преобразования типов.
      > Явная (explicit) - когда тип выражения определяет разработчик.
      > НЕявная (impicit) - когда тип выражения определяет компилятор или интерпретатор.

>> Совместимость типов - механизм, по которому сопоставляются 2 типа.
>> Совместимость типов по ТИПИЗАЦИИ:
      1. Номинативная типизация - проверка по названию типа (при наследовании по названию родителей).
      2. Структурная типизация - проверка по описанию (свойствам и методам), присуща только языкам с явной типизацией.
      3. Утиная типизация - как структурная, но присуща только языкам с динамической типизацией.
>> Совместимость типов по ВАРИАНТНОСТИ (исп. иерархия наследования):
      1. Ковариантность - позволяет исп. конкретный тип там, где ожидается менее конкретный тип (норм для чтения).
      2. Контрвариантность - позволяет исп. менее конкретный тип там, где ожидается конкретный тип (норм для записи).
      3. Инвариантность - позволяет исп. только заданный тип.
      4. БИвариантность - позволяет исп. все предыдущие варианты (не-типобезопасный).

!!! Рекомендуется разрабатывать в режиме --strictNullChecks.
!!! Компилятор проверяет на соответствие 
      - тип переменной и тип присваиваемого значения
      - указанный тип возвращаемого функцией значения и фактически возвращаемое значение

>> Any - базовый тип, остальные типы его подтипы. Рек. исп. только в крайних слуаях или тестах.
      > Если тип переменной или значение не указаны, то тип Any.
>> Фу-я, которая не возвращает значений или возвращает соответствующие void типы, получит тип void.

>> Примитивные типы: 
      + number, string, boolean, bigInt, symbol
      + null, undefined, void, never, unknown, enum.

>> Совместимость типов:
      > null (--strictNullChecks): 
            any = null
            null = null
            null = any
      > undefined (--strictNullChecks):
            any = undefined
            undefined = undefined
            undefined = any

      > void (--strictNullChecks) - предназначен для указания, что фу-я не возвращает никакого значения:
            any = void
            void = void
            void = any
            void = undefined

      > never - предназначен для указания, что фу-я никогда не выполнится успешно, например при обработке ошибок:
            "все типы" = never
            never = never

      > unknown - как any, но типобезопасный: разрешено исп. только с операторами ===, !==, ==, !=, &&, ||, !
            any = unknown
            unknown = "все типы"
            - в Union перекрывает все типы кроме any
            - в Intersection будет перекрыт всеми типами
            - в keyof возвращает never

>> Совместимость объектов (структурная):
      > Т1 совместим с Т2, если Т2 содержит все обязательные поля Т1 (Т1 = Т2).
      > Слабый тип (Weak type) - содержит только НЕобязательные поля.
            Совместим с любым типов, который содержит хотя бы 1 совпадающее поле.
      > При наличии в классе модификатора доступа protected или private, он не будет совместим с другими классами.
            НЕ влияет на совместимость по наследованию.
      > При проверке на совместимость НЕ учитываются constructor и static поля.

>> Совместимость фу-й:
      > Если одинаковое кол-во параметров с совместимыми типами (при выкл. --strictFunctionTypes БИвариантность).
      > Если совместимые типы необязательных параметров.
      > Меньшее кол-во параметров совместимо с бОльшим кол-вом параметром (F(x, y) = F(x)).
      > Возвращаемый тип void совместим с любым возвращаемым типом.
      > Если фу-и содержат параметры типа (F<T1, T2>() = F<T3>()).

>> Совместимость объединений (Union):
      > Объединение с бОльшим кол-вом типов совместимо с объединением с меньшим кол-вом типов (T1 | T2 | T3 = T1 | T2).

#* enum
	#! Лучше исп. obj as const, чем enum
	= список перечисления логически связанных именованных констант 
		# enum EnumRoles { ADMIN, GUEST, USER }
    - Значения могут иметь тип number или string
    - Каждое след. значение === пред. значение + 1. Если пред. значение string, то Error
    - При наличии в enum констант с числовым значением он всегда будет совместим с number
    - Рекомендуется объявлять с помощью const (намного производительнее)
	- Можно исп. когда нужно 2-сторонняя ассоциация str : num <=> num : str

#* object
	= базовый сс лочный тип для всех ссылочныз типов
	- Представлен пустым ассоциативным массивом

#* Array (type[])
	- ссылочный массивоподобный тип
    - При Union элемент массива может быть одного из указанных типов
    - Объявление с помощью:
		#- new
        	> const arr: (number | string)[]
		#- Union
			> new Array<number | string> ('str', 2)

#* Tuple (кортеж)
	= последовательность типов, каждый из которых ограничивает элемент массива под соответствующим индексом
    - Можно исп. с оператором rest
            > function foo(...rest: [number, string])
    - Определение может содержать только один spread-оператор, который может стоять только после необязательных типов
            > type Tuple = [number, ...boolean[]]
            > const foo: [string?, ...Tuple]
    - При наличии необязательных типов свойство length будет типа Union состоящий из литеральных типов number
            > const foo: [number?, string?, boolean] 
				# typeof foo.length === 1 | 2 | 3

#* Литеральный тип Uniqie Symbol 
	- Может быть указан след. способами:
      	1. const FOO: unique symbol = Symbol.for('key')
			# Только через 'const'
      	2. class Foo { public static readonly bar: unique symbol = Symbol.for('key') } 
			# Только public static readonly

#* Шаблонный литеральный тип
	= строчный тип использующий шаблонные строки
		# Пример:
			type EventName = 'click' | 'change'
			type EventHandler = `on${EventName}`
	- Операторы преобразования:
    	> ${uppercase "str"} === "STR"
    	> ${lowercase "STR"} === "str"
    	> ${capitalize "str"} === "Str"
    	> ${uncapitalize "Str"} === "str"
      
>> function foo(this: T) {} - this указывает тип контекста и не считается за аргумент.
>> typeof (оператор запроса типа) - можно исп. в местах указания типа.
>> Union (|) : значение может принадлежать только 1 типу.
>> Intersection (&) : значение должно принадлежать ко всем типам одновременно.

>> Псевдоним типа (type alias):
      1. Объявлять можно только в молулях, функциях, методах класса
      2. Модули, содержащие только псевдонимы типов, после компиляции включаться в сборку не будут
      3. Расширять можно только объектные типы

>> Интерфейс (interface):
      1. Объявлять можно только в модулях, функциях, методах класса
      2. Нельзя исп. модификатор 'static'
      3. Класс, который реализует (implements) интерфейс должен реализовать все поля интерфейса
      4. Реализация интерфейсов:
            - class Foo implements IFoo, IBar {}
      5. Расширение класса: 
            - class Foo extends SuperFoo implements IFoo {}
      6. Расширение интерфейса:
            - interface IFoo extends IBar, ISnafoo
      7. Нельзя указывать аксессоры класса. Но сами поля можно исп. для аксессоров
      8. Расширение класса интерфейсом (создание интерфейса для уже существующего класса):
            - interface IFoo extends Foo {} 
            > Класс, у которого все поля public может реализовать любой класс
            > Если класс содержит поля 'protected', 'private', то его может реализовать только тот же класс или его потомки
      9. Интерфейс с конструкторм для класса:
            - interface IFooConstructor { new (foo: T): void }
      10. Интерфейс для 'Function Expression':
            - interface IFoo { (foo: T): void }
      11. Inline Interface:
            - const foo: { bar: T } = new Foo()
            > Совместимость с 'interface' по структурной типизации
      12. В одной ОВ одноимённые интерфейсы объединяются, при этом:
            > Переопределять тип свойства запрещено
            > Метод с разными сигнатурами будет работать по принципу 'перегрузки' (полиморфизм)
      13. Если в одной ОВ объявлены одноимённый интерфейс и класс, то компилятор реализует интерфейс этим классом

>> Модификаторы доступа - ключевые слова для управления доступом (ОВ) данных:
      1. В классах:
            > public = стандартное поведение
            > protected = класс и потомки
            > private = класс
      2. Модификатор конструктора:
            > public = стандартное поведение
            > protected = запрещает создание экземпляров
            > private = запрещает создание экземпляров и расширение

>> Модификатор 'readonly':
      - нельзя изменять поле объекта, которое в его типе обозначено readonly
      - можно изменять поле класса, которое в его интерфейсе обозначено readonly
      - неявное присвоение литерального типа:
            class Foo { readonly foo = 'literal value' } // typeof foo === 'literal value'

>> Краткая запись инициализации полей класса:
      class Foo { constructor(
            public a: T, 
            protected b: T, 
            private c: T, 
            readonly d: T
      ) {} }

>> При наследовании запрещено переопределение родительских полей дочерним классом.

>> Необязательные (optional) поля, параметры, методы (--strictNullChecks):
      > { foo?: number }  // тип number | undefined
      > { foo?: any }     // тип any

>> Generic (обобщение) - тип, принимающий в качестве параметров более конкретные типы, 
      которые передаются как аргументы во время создания экземпляра обобщения:
      > Сигнатура:
            type Foo<T1, T2, T3> = { 
                  prop: T1
                  method(arg: T2): T3
            }
      1. Обобщения можно объявлять с помощью type, interface, class, function (FD, FE)
      2. Конкретные типы передаются как аргументы во время создания экземпляра обобщения
      3. Переопределение обобщения запрещено
      4. Открытое обобщение - если хотя бы один параметр (Foo<T1, string>)
      5. Закрытое обобщение - если вместо параметров конкретные типы (Foo<number, string>)
      6. Расширение параметров обобщения (generic constraints):
            > type Foo<T1 extends T2>
            - расширять можно любые типы 
            - порядок расширения не имеет значения
            - при расширении any параметр станет типом unknown:
                  > type Foo<T extends any> = { prop: T } // T === unknown
      7. Значение параметра обобщения по умолчанию (generic parameter defaults): 
            > type Foo<T = string>
            - все параметры со значением по умолчанию должны стоять после параметров без значения по умолчанию

>> import type / export type - импорт / экспорт любых сущностей в качестве типов, при этом:
      1. При экспорте фу-и и классы не должны содержать реализацию (вызов, создание экземпляров и т.п.)
      2. Для импортированных фу-й и обычных объектов нужно исп. typeof:
            - const foo: typeof bar
      3. Классы не могут учавствовать в наследовании

#* Явное преобразование типов
    - Преобразование к совместимому типу: 
            > foo as Type или <Type>foo  
    - Приведение к несовместимому типу, то есть в любой другой тип: 
            > (foo as any) as Type
    - Приведение к константе (as const):
		#- Иммутабельность ссылочных типов (все поля рекурсивно делаются readonly):
			> let foo = { a: { b: 1 }, c: '2', d: e } as const
        #- Значениями НЕ могут выступать переменные 
			> let foo = bar as const # Error 

#* Type Guard
	= проверка или фу-я для проверки типа переданного значения
	- Фу-я должна всегда возвращать тип boolean
		# Пример:
      		> function foo(value: number | string): value is number { 
        	    return typeof value === 'number' 
      		}
	- Для объектов можно исп. if + in
		# Пример:
			> if ('prop' in obj)
    - Для классов нужно исп. if + instanceof
		# Пример:
			> if (obj instanceof Object)

#* satisfies
	= проверяет на структурную совместимость
	- При НЕсовместимости ошибка
		# А оператор as принудительно установит указанный тип

#* Assertion functions
	= фу-я для проверки типа переданного значения
	- Как Type Guard, но в случае несоответствия выбрасывает ошибку
	- Сигнатура:
		#- Проверка на конкретный тип:
			> function foo(value: unknown) asserts value is number { 
        		if (typeof value !== 'number') 
					throw new Error('Not number type!') 
      		}
		#- Кастомная проверка
			> function foo(value: unknown) asserts value { 
        		if (value === null || value === undefined) 
					throw new Error('Null/Undefined type!') 
      		}

>> Вывод типов (авто-определение):
      1. TS проверяет типы даже если они явно не указаны.
      2. Контекстная типизация - авто-определение типов на основе контекста, в котором они исп.
      3. Массив, содержащий элементы, связанные наследованием, получит самый базовый из них тип.
      4. const foo = 'str'    // тип 'str'
      5. let foo = 'str'      // тип 'string'
      6. const foo = new F()  // тип F
      7. const foo = [1, 'str']           // тип (number | string)[]
      8. const foo = { a: 1, b: 'str' }   // тип { a: number b: string } 

#* keyof
	= возвращает литеральное объединение на основе публичных нестатичных ключей
    	> type Foo = keyof { a: 1, b: true, c: 'str' } === 'a' | 'b' | 'c'
    	> type Foo = keyof {} === never # т.к. нет ключей
    	> function foo<O, K extends O>(obj: O, key: keyof K) { return obj[key] } === foo(someObj, 'someKey')
    	> type ArrayKeys = keyof [3, 4] === '0' | '1' | 'length' | 'push' |  # и т.д.

>> Поиск типов (Lookup Types) - получение типа по ключу (Error, если такого ключа нет):
      - в интерфейсах:
            > const foo: I['age'] = 1                 // тип number
            > const foo: I['age' | 'name'] = 'str'    // тип number | string
      - в классах можно получить только по ключам, которые присущи экземплярам

#* Mapped Types (сопоставленные типы)
	= может содержать только 1 выражение:
    - Сигнатура: 
    	> type U = 'foo' | 'bar' | 7 # === один литерал или объединение литералов
    	> type MT = { [K in U]: T } # === type T1 = { foo: T, bar: T, 7: T }
    - Обобщение + keyof:
    	> type MT<T> = { [K in keyof T]: T[K] }
    - Обобщение + extends + keyof:
    	> type MT<T, U extends keyof T> = { [K in U]: T[K] }

>> tsconfig флаги:
      --strictNullChecks - компилятор не пропускает undefined и null, где ожидаются другие типы
      --noImplicitThis - проверяет, что this всегда известен при использовании this
      --noImplicitAny - подсвечивает неопределённые типы в коде (неявный any)
      --noUncheckedIndexedAccess - при обращении к динамическим ключам в объектных типах строго проверяет их наличие
      --noPropertyAccessFromIndexSignature - запрещает обращение к динамическим ключам через точечную нотацию
      --strictPropertyInitialization - проверяет чтобы поля класса были инициализированы
      --isolatedModules - делает дополнительные проверки на связанность типов между модулями, в т.ч.:
            - обязывает исп. import type / export type
            - запрещает const enum
            - выдаёт ошибку при отсутствии экспорта в модуле
      --importsNotUsedAsValues - отвечает за поведение импортов типов при сборке. Значения:
            1. remove (по умолчанию - РЕКОМЕНДУЕТСЯ) - удалить
            2. preserve - сохранить
            3. error - как preserve, но ошибка если импорт исп. только для типов
      --strictFunctionTypes - более строгая проверка сигнатур фу-й

>> Объектный тип с динамическими ключами:
      - нельзя исп. модификаторы: static, public, protected, private
      - допустимые типы ключей: string, number, symbol
      - значения могут быть любого типа и совместимых ему типов 
      - типизация распостраняется на все ключи объекта
      > Сигнатура:
            1. type Foo = { [key: string]: T }
            2. interface/class Foo { [key: string]: T }

>> Абстрактный класс:
      - нельзя создать экземпляр
      - может расширять любые другие классы
      - может реализовывать интерфейсы
      > Абстрактный метод/свойство:
            - свойству можно задать значение
            - методу нельзя задать значение
            - в обычном классе необходимо переопределять (при наследовании)
      > Сигнатура:
            abstract class AFoo extends Foo implements IFoo { 
                  abstract aprop: string = 'default value' 
                  abstract amethod(arg: string): string
                  prop: string = 'prop'
                  method(arg: string): string { console.log('method') }
            }

>> Полиморфный тип this - принадлежит к тому же типу, что и экземпляр класса:
      - сохраняется наследование родительских классов (F-boounded polymorphism)
      > Сигнатура:
            class Foo { method(): this { return this } }

>> (!) Definite Assignment Assertion Modifier - оператор, сообщающий компилятору не проверять переменную на инициализацию. 
      - РЕКОМЕНДУЕТСЯ избегать его исп.
      * Пример: 
            let foo: T
            console.log(foo) // Error
            let foo!: T 
            console.log(foo) // Ok

>> (!) Definite Assignment Assertion - оператор, сообщающий компилятору, что отсутствие значения 
      у переменной в указанном месте допустимо.
      * Пример:
            let foo: number
            bar()
            foo! + foo! // Ok
            function bar() { foo = 1 }

>> (!) Not-Null Not-Undefined Operator - указывает компилятору, что значение переменной или поля не null и не undefined:
      - исп. когда значение не будет null или undefined, но компилятор выдаёт ошибку
      - если в runtime значение будет null или undefined, то будет ошибка
      - РЕКОМЕНДУЕТСЯ избегать его исп.
      * Пример:
            let foo: string | null = 'value'
            foo!.length // Ok
            type T = { foo?(): string }
            function bar (foobar: T) { return foobar!.foo } // Ok
       
>> Реализация класса другим классом (class Foo implements Bar) происходит по тем же правилам, 
      что и расширение класса интерфейсом (interface IFoo extends Foo).

>> Дискриминантное объединение (Discriminated Union)  - как обычное объединение, но:
      1. Исп. только в классах
      2. Содержит только ссылочные типы
      3. В каждом ссылочном типе указывается один идентификатор (дискриминант) - свойство литерального типа (не symbol)

>> Условный тип : 
      > T1 extends T2 - в условных типах проверяет совместимость Т1 с Т2
      > type Foo<T> = T extends number ? string : boolean 
            const foo: Foo<number> = 'str'            // тип string
            const bar: Foo<number | object> = 'str'   // тип string | boolean

>> infer T - объявляет переменную T внутри условного типа (только после extends), 
      в которую компилятор передаёт некую информацию о типе из передаваемого аргумента в обобщение, 
      в зависимости от места объявления переменной:
      > type Foo<T> = T extends infer X ? X : never // всегда вернёт тип X, а именно такой же как T
      > type Foo<T> = T extends (p: infer X) => infer Y ? { p: X, r: Y } : void

#* Utility Types
	= встроенные типы для преобразований передаваемых типов. Например:
	> Awaited<Promise<T>>
		- Возвращает тип данных T, который возвращает переданный тип Promise
    > Readonly<O>
		- Добавляет каждому полю объекта модификатор readonly
    > Partial<O>
		- Делает все обязательные поля объекта НЕобязательными
    > Required<O>
		- Делает все НЕобязательные поля объекта обязательными
    > Pick<O, K>
		- Фильтрует объект: останутся только поля с ключами типа K
    > Omit<T, K>
		- Возвращает тип Т, без ключей указанных в K
    > Exclude<T, U>
		- Возвращает тип T, только с исключёнными полями, которые также есть в типе U
    > Extract<T, U>
		- Возвращает тип с полями общими для T и U
    > NonNullable<T>
		- Возвращает тип T, из которого удалены поля null и undefined
    > ReturnType<T>
		- Возвращает тип возвращаемого фу-ей значения
	> Parameters<F>
		- Возвращает кортеж, содержащий типы параметров фу-и
    > InstanceType<C>
		- Возвращает тип экземпляра на основе переданного класса (C === typeof SomeClass)
    > ConstructorParameters<C>
		- Возвращает кортеж, содержащий типы параметров конструктора класса
	> Record<K, V>
		- Возвращает тип объкта с ключами типа K и значениями типа V

#* Встроенные readonly типы
    > ReadonlyArray<T> # === readonly T[]
    > ReadonlyMap<K, V>
    > ReadonlySet<T>


////////////
7.   Nest
////////////

> npm i --save class-validator class-transformer (для валидации данных, например полей DTO)

#* DTO (Data Transfer Object) 
	= объект, который определяет ожидаемый тип получаемых данных

#* Архитектура
	dto       
		- хранит типы данных (класс/интерфейс), которыми обмениваются клиент и сервер.
	entitites 
		- хранит классы, описывающие структуру таблиц БД; используются ORM для обращения к БД.
	scalars   
		- хранит классы, описывающие пользовательские типы (скаляры) для GraphQL.

#* Декоратор
	= фу-я, модифицирующая или добавляющая методы и свойства класса
    - Определяет тип модуля (файла):
        @Module() # Модуль
        @Controller() # Контроллер
        @Injectable() # Сервис (роутер)

    - Определяет тип метода запроса:
        @Get()  @Post()  @Put()  @Patch()  @Delete()  @All()
      
    - Предоставляет доступ к параметру запроса:
        @Req() / @Res() # К стримам req / res
        @Body() # К телу запроса
        @Param() # К URL-параметрам
        @Query() # К query-параметрам
        @Headers() # К заголовкам
      
    - Предоставляет доступ к WebSocket:
        @WebSocketGateway() # Создаёт WebSocket-соединение (шлюз)
        @SubscribeMessage() # Доступ к полученному сообщению
        @MessagePattern() # Доступ к сообщению микросервиса

    - Прочее:
        @Scalar() 
			#- Описывает скаляр
		@Exclude() 
			#- Исключает поле из ответа API
			#- Можно обернуть класс, тогда все поля по умолчанию будут исключены из ответа
		@Expose() 
			#- Добавляет поле в ответ API
		@HttpCode()
			#- Переопределяет статус-код успешного ответа

#* Свойства @Module({...})
    imports 
		- импортирует модули, providers которых становятся доступны в текущем модуле
    providers 
		- регистрирует зависимости (фу-и, сервисы) пренадлежащие этому модулю
    controllers 
	 	- регистрирует контроллеры
    exports 
		- экспортирует providers

#* Scalar
	= класс, содержащий методы для решения конфликта типов обмениваемых данных
	- Содержит методы преобразования данных

#* Guard
	= класс, определяющий будет ли обработан запрос контроллером
    - То есть служит для всяческих проверок запроса перед передачей его контроллеру

#* Pipe
	= класс, служащий для преобразования и валидации полученных данных
    - Вызывается до вызова контроллера

#* Interceptor
	= класс, служащий для преобразования полученных или отправляемых данных
    - Исп. для кеширования
    - Может быть вызван до или после контроллера

> createParamDecorator
	- метод для создания кастомного декоратора
> useGlobalPipes 
	- добавляет глобально Pipes
> useGlobalInterceptors
	- добавляет глобально Interceptors


///////////////
8.   GraphQL
///////////////

>> Отличия GraphQL и REST API:
      - GraphQL                                            - REST API
      > Описание типа зароса (поля)                         > Описание адреса запроса (endpoints) 
      > Данные разных типов в одном запросе                 > Данные разных типов отправляются отдельными запросами 


//////////////
9.   Prisma
//////////////

#* ORM (Object-Relational Mapping) 
	= ассоциативная взаимосвязь объектов приложения и таблиц БД

#* Миграции
	= процесс синхронизации структуры БД с её схемой в ORM-схеме
	- Исп. для поддержания данных и истории изменений БД, при новых изменениях её структуры

#* Seeding
	= наполнение БД необходимыми или тестовыми данными перед запуском приложения

#* Prisma ORM
	= используя СУБД, позволяет работать с БД без SQL-запросов (с помощью JS).

>> Типы: String - Boolean - Int - BigInt - Float - Decimal - DateTime - Json - Bytes.
>> columnType[] - определяет значение поля как массив, такое поле всегда обязательное.

>> Атрибуты колонки:
      > @id === PRIMARY KEY
      > @unique === UNIQUE
      > @default(value) === DEFAULT
      > @updateAt - автоматически обновляет дату изменения записи
      > @db - позволяет исп. типы специфичные для конкретной БД

>> Атрибуты таблицы:
      > @@id - позволяет определить составной PK
      > @@unique - позволяет определить составное значение уникальности записи
      > @@index - определяет индекс в БД

>> Фу-и в атрибутах:
      > autoincrement() === AUTOINCREMENT
      > uuid()/cuid() === UUID/CUID
      > now() - возвращает текущий timestamp
      > dbgenerated(value) - передаёт значение в @default, которое невалидно в Prisma
	
#* Ключевые факторы, которые учитывает Prisma при мигрировании (prisma migrate dev)
	- Схема (schema.prisma)
	- История миграций (prisma/migrations/)
	- Таблица миграций в БД (_prisma_migrations)
???	- Схема БД

#* Shadow Database
	= временна БД
	- Создаётся и удаляется автоматически при запуске prisma migrate dev
	- Исп. для выявления проблем и возможных потерь данных


////////////
10.  gRPC
////////////

#* Свойства
    - Фреймворк
    - Исп. HTTP/2
    - Исп. Protocol Buffers (protobuf)
    - Типобезопасный
    - Кросс-языковой

#* Алгоритм проектирования
    1. Маршруты - названия удалённых фу-й
    2. Формат, тип, размер обмениваемых данных
    3. Однозначное соответствие ошибок к их описанию и алгоритму обработки
    4. Максимальное время ожидания ответа
    5. Масштабируемость - расчётное количество одновременно обрабатываемых запросов
    6. Авторизация
    7. Логгирование
    ? Load Balancing
    ? Language Interop

#* Сопособы клиент-серверного взаимодействия (API)
    - Унарный
        # 1 запрос - 1 ответ
        > rpc Foo(Request) returns (Response)
    - Серверный поток 
        # 1 запрос - поток ответов
        > rpc Foo(Request) returns (stream Response)
    - Клиентский поток 
        # поток запросов - 1 ответ
        > rpc Foo(stream Request) returns (Response)
    - Двунаправленный поток 
        # поток запросов - поток ответов
        > rpc Foo(stream Request) returns (stream Response)


-----------------------
* * * Базы данных * * *   
-----------------------

>> Реляционная база данных (РБД) - набор данных с заданными взаимосвязями между таблицами.
>> CRUD - акроним, обозначает 4 базовые фу-и в работе с БД: Create, Read, Update, Delete.
>> Роль - аккаунт в СУБД.
>> Агрегатная функция - выполняет вычисления над НАБОРОМ значений и возвращает ОДНО значение (AVG, COUNT).
>> Транзакция - последовательность запросов, которые:
      - гарантировано все выполнятся успешно или все не выполнятся
      - подчиняются строгим правилам

>> ACID - принципы работы транзаций:
      1. Atomicity (Атомарность) - транзакция должна быть выполнена или не выполнена целиком. 
      2. Consistency (Согласованность) - запланированная логика приложения не должна быть нарушена.
      3. Isolation (Изолированность) - используемые в транзакции данные больше нигде не должны быть доступны.
      4. Duratility (Долговечность) - нельзя откатить транзакцию после успешного её завершения.

>> Уровень изоляции - степень доступа к используемым транзакцией данным (чем строже уровень, тем хуже производительность):
      1. Serializable - гарантирует выполнение транзакций, как если бы они выполнялись последовательно.
            Чтобы не блокировалась вся таблица необходимо:
                  - A - Настраивать индексы
                  - B - Использовать SNAPSHOT (отдельно хранящаяся копия таблицы)
      2. Repeatable read - read доступ к зафиксированным данным.
      3. Read committed - read/write доступ к зафиксированным данным.
      4. Read uncommitted - read/write доступ ко всем данным.

>> Нормальная форма (НФ) - ограничения и правила организации таблиц:
      - нет дубликатов полей
      - нет аномалий при манипуляциях над данными
      - первичный ключ
      - одна ячейка - одно значение
      - логичная и понятная структура связей между таблицами

>> Виды связей:
      1. one-to-many (учитель - преподаваемые предметы)
      2. one-to-one (человек - паспорт)
      3. many-to-many (учителя - студенты)

!!! "Высокая селективность" по данному критерию означает: мало вариантов - быстрое нахождение.
!!! "Низкая селективность" наоборот: много вариантов.

#* Способы защиты от SQL-иньекций
      - Исп. prepared statements (подготовленные выражения)
            # Скомпилированние шаблоны запросов (хз как), которые лишь принимают отфильтрованные аргументы 
      - Исп. ORM
      - Фильтрация и валидация данных на сервере


///////////
1.   SQL
///////////

#* SQL (Structured Query Language)
    = это декларативный язык структурированных запросов

#* Типы объединений
    1. INNER JOIN || JOIN
        - записи имеющиеся в обеих таблицах.
    2. LEFT/RIGHT JOIN
        - записи из левой/правой табл., даже при отсутствии таковых в правой/левой табл.
    3. FULL JOIN
        - все записи обеъединяемых таблиц.
    4. CROSS JOIN
        - все возможные комбинации столбцов обеих таблиц.
    5. SELF JOIN
        - объединяет табл. саму с собой.

#* Команды
    1. SELECT
        - аналог return (SELECT 2 + 2; - вернёт таблицу с колонкой 2 + 2 и рядом 4)
    2. INSERT INTO SELECT
        - заполнение табл. с помощью другой табл.
        - типы полей должны совпадать
    3. SELECT INTO
        - вставляет данные из табл. в новую табл.
    4. UPDATE/DELETE
        - для обновления/удаления записей в табл.
    5. GROUP BY
        - всегда исп. с 'агрегатными фу-ми' и указанными полями группировки.
    6. HAVING
        - как WHERE, но только для агрегатных фу-й при исп. GROUP BY
    7. DISTINCT
        - для выборки строк исключая дубликаты
    8. BETWEEN x AND y;
        - выборка в диапазоне указанных значений
    9. IN
        - алиас для множества OR
    10. LIKE '%Test_'
        - упрощенный RegExp, где % - 0 и более любых символов, _ - 1 любой символ
    11. WHERE EXISTS (подзапрос)
        - TRUE, если подзапрос вернёт хотя бы одну строку 
    12. ANY/ALL (подзапрос)
        - TRUE, если ЛЮБАЯ/КАЖДАЯ строка подзапроса выполняет условие в WHERE (ALL можно исп. с SELECT, WHERE, HAVING)
    13. CAST (value AS type)
        - возвращает преобразованное в указанный тип значение

#* Условные выражения (Conditional Expression)
    1. CASE WHEN THEN ELSE END
        - аналог if-else
    2. COALESCE
        - возвращает 1-й не-NULL-аргумент
    3. NULLIF (v1, v2)
        - возвращает NULL, если v1 = v2, иначе v1
    4. IFNULL (v1, v2)
        - возвращает v2, если v1 = NULL, иначе v1
    5. ISNULL (v)
        - возвращает 1, если v = NULL, иначе 0
    6. GREATEST/LEAST
        - возвращает наибольшее/наименьшее значение из списка

#* VIEW (представление)
    = это алиас для запроса
    - Также полезно для ограниченного доступа к таблице
    - Постоянный объект БД
    - Типы представлений:
		#- Модифицируемое предтавление
        	#/ Может изменять исходную таблицу при условии, что нет readonly-операторов.
        #- Материализованное представление
        	#/ Это копия выбранной части таблицы.
        	#/ Хранится отдельно от исходной таблицы.
        	#/ Ускоряет тяжёлые запросы, так как обращение к копии, а не к исходной таблице.
    - MATERIALIZED VIEW
        #- Кеширует результат запроса (можно обновлять)
        #- Исп. для повышения скорости запроса
    - CREATE OR REPLACE VIEW
        #- Для изменения VIEW
    - WITH CHECK OPTION
    	#- Проверяет условия в представлении (WHERE) при попытке изменить таблицу
    - WITH [RECURSIVE] AS 
        #- Эту команду называют Common Table Expression (CTE)
        #- Временная таблица, то есть НЕ является постоянным объектом БД
        #- Вызывается только для одного запроса, то есть можно исп. только в одном запросе

>> Объединение выборки (SELECT) из таблиц с одинаковыми колонками:
      > UNION [ALL]
      > INTERSECT [ALL]
      > EXCEPT [ALL]
      (ALL - разрешает дубликаты)

>> DELETE FROM table_name; ----| - удалит все записи в табл. (есть логи об удалении)
>> TRUNCATE TABLE table_name; -| - (нет логов об удалении)

>> INDEX - содержит указанные столбцы и инф. о местоположении в памяти каждого ряда. 
      - ускоряет поиск без необходимости сканировать каждую запись в таблице
      - PRIMARY KEY - спец. автоматически сгенерированный ИНДЕКС
>> REINDEX - сбрасывает индексы до начального значения.

>>          CREATE FUNCTION                           CREATE PROCEDURE
      - нельзя создавать транзакции             - можно исп. для управления транзакциями
      - можно RETURN значение                   - нельзя возвращать значение
      - можно исп. в SQL-запросах               - нельзя исп. в SQL-запросах

>> Порядок операторов:
      1. SELECT > FROM > WHERE > GROUP BY > HAVING > ORDER BY
      2. ALTER TABLE t_1 > ADD CONSTRAINT name > FOREIGN KEY (t_1_id) > REFERENCES t_2(id) > ON DELETE


//////////////////
2.   PostgreSQL
//////////////////

>> Инструкция подготовки PostgreSQL к работе:
      1. Установить PostgreSQL модуль [ sudo apt install postgresql ]
      2. Войти в роль (аккаунт) автоматически сгенерированную при запуске СУБД [ sudo -u postgres psql ]
            ИЛИ создать новую роль [ sudo -u postgres createuser --interactive ]
      3. Создать БД [ sudo -u postgres createdb db_name ]

>> Основные команды в psql:
      > \conninfo             - проверка статуса
      > \password role_name   - сменить пароль
      > \l                    - список БД
      > \c db_name            - выбрать БД
      > \dt                   - список таблиц
      > \d table_name         - список столбцов таблицы

>> Типы данных: 
      0. https://postgrespro.ru/docs/postgresql/16/datatype
      1. SERIAL         - целое с автоувеличением (4 байта)
      2. INTEGER        - стандартное целое (4 байта)
      3. VARCHAR(n)     - строка ограниченной переменной длины
      4. TEXT           - строка НЕограниченной переменной длины
      5. TIMESTAMP      - дата и время без часового пояса, (8 байт)

>> Ограничения (constraints): 
      0. https://postgrespro.ru/docs/postgresql/16/ddl-constraints
      1. PRIMARY KEY    - первичный ключ может быть составным (compound key)
      2. UNIQUE         - указывает, что столбец должен иметь уникальное знавение
      3. NOT NULL       - запрещает значение NULL для столбца (по умолчанию разрешено, кроме PK)
      4. DEFAULT        - определяет значение стобца по умолчанию
      5. CHECK          - ограничение на значения соответствующие условию
      6. CONSTRAINT     - позволяет задать имя ограничению
      7.1. REFERENCES main_table (main_table_column)
      7.2. FOREIGN KEY (columns) REFERENCES main_table (main_table_columns)   

>> x || y - оператор конкатенации.

>> По умолчанию, при возникновении ошибки транзакция автоматически откатываеся.
>> BEGIN ... COMMIT - блок транзакции
>> SAVEPOINT save_name - точка сохранения, до которой можно откатиться.
>> ROLLBACK [savepoint_name] - откат всей транзакции или до указанного SAVEPOINT.
>> ISOLATION LEVEL - уровень изоляции:
      > SERIALIZIBLE
      > REPEATABLE READ
      > READ COMMITED (значение по умолчанию)
      > READ UNCOMMITED
>> SET TRANSACTION SNAPSHOT snapshot_id - устанавливает копию таблицы, с которой будет работать транзакция.
      > Получить snapshot_id можно вызвав фу-ю pg_export_snapshot() в уже выполняющейся транзакции.

>> Условные операторы:
      1. IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF
      2. CASE WHEN ... THEN ... ELSE ... END CASE\

>> RAISE [level] - выбрасывает ошибку.

>> Оконные фу-и (Window Functions):
      someFunc() OVER (PARTITION BY col_1, col_2 ORDER BY col_1 ASC)

#* psql
    #/ sudo -u postgres psql
        - зайти в psql-CLI под пользователем postgres
	#/ sudo -u postgres psql -d имя_бд -f /путь/к/файлу.sql
    	- подключится к БД (-d) и выполнить команды из .sql-файла (-f)
 	#/ sudo -u postgres createdb имя_бд
    	- создать БД
	#/ sudo -u postgres createuser имя_пользователя
    	- создать пользователя

#* pg
	= модуль для взаимодействия с PostgreSQL в NodeJS
	- pg.Client
    	#- Класс для создания одиночного подключения к PostgreSQL (локальные скрипты, тестирование)
	- pg.Pool
    	#- Класс для создания набора открытых и повторно используемых соединений с PostgreSQL (приложения, api-сервисы)


//////////////
3.   SQLite
//////////////

>> SQLite - СУБД (аля-библиотека на С) для работы с БД:
      - Serverless: отсутствует отдельный серверный процесс, то есть непосредственно обращается к файлу БД на диске
      - Self-contained: не зависит от платформы и окружения, то есть самодостаточная библиотека
      - Zero-configuration: нет обязательных настроек
      - Transactional: транзакционность, то есть безопасное и эффективное управление данными
      - динамическая типизация (type affinity)
      - множественные параллельные операции чтения
      - операция записи только одна и исключает любые другие параллельные операции

>> Storage Classes (классы хранения) - типы данных, которые внутри движка оперируют несколькими подтипами данных:
      > NULL
      > INTEGER - целое положительное или отрицательное число (до 8 байт).
      > REAL - число с плавающей точкой (8 байт)
      > TEXT
      > BLOB

>> Types Affinity (сходство типов) - правила конвертации типов внутри движка:
      > TEXT === NULL/TEXT/BLOB 
      > NUMERIC === любой из 5 типов
      > INTEGER === NUMERIC (разница между ними только при конвертациях типов)
      > REAL === NUMERIC (разница в том, что REAL конвертирует INTEGER в числа с плавающей точкой)
      > BLOB - не конвертируется


-------------------------
* * * Полезный софт * * *
-------------------------

>> randomUUID() - возвращает строку типа v4 UUID (Universally Unique Identifier) из 36 случайных символов, 
      используя криптографически безопасный генератор случайных чисел.


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
1.   Cache-Wrapper + call + apply 
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

let workers = {
   someProp: 10,
   someMethod(arg1, arg2) {
      return arg1 + arg2 + this.someProp
   },
}
workers.someMethod = cachingDecorator(workers.someMethod, hash)
    
function hash() {
   return [].join.call(arguments)
}
function cachingDecorator(func, hash) {
   let cache = new Map()
    
   return function (...args) {
      let key = hash(arguments)
      if (cache.has(key)) 
            return cache.get(key)

      let result = func.apply(this, args)
      cache.set(key, result)

      return result
   }
}

console.log(workers.someMethod(1, 2))


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
2.   Object.prototype.toString - расширенный typeof
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

let objToString = Object.prototype.toString

let user           = { [Symbol.toStringTag]: 'User' }       
let array          = []                                     
let number         = 123                                    
let string         = 'str'                                  
let boolean        = true                                   
let nullValue      = null                                   
let functionValue  = alert                                  
let undefinedValue = undefined                              

objToString.call(user)              // [object User]    
objToString.call(array)             // [object Array]
objToString.call(number)            // [object Number]
objToString.call(string)            // [object String]
objToString.call(boolean)           // [object Boolean]
objToString.call(nullValue)         // [object Null]
objToString.call(functionValue)     // [object Function]
objToString.call(undefinedValue)    // [object Undefined]


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
3.   Обёртывание исключений
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

class ReadError extends Error {
      constructor(message, cause) {
            super(message)
            this.cause = cause
            this.name = 'ReadError'
      }
}
class ValidationError extends Error {
      constructor(message) {
            super(message)
            this.name = this.constructor.name
      }
} 
class PropertyRequiredError extends ValidationError {
      constructor(property) {
            super('Absent property: ' + property)
            this.property = property
      }
}

function readUser(json) {
      let user
    
      try {
            user = JSON.parse(json)
      } catch (error) {
            if (error instanceof SyntaxError) 
                  throw new ReadError(error.name, error)
            else 
                  throw error
      }
      try {
            validateUser(user)
      } catch (error) {
            if (error instanceof ValidationError) 
                  throw new ReadError(error.name, error)
            else 
                  throw error
      }
}
function validateUser(user) {
      if (!user.age) 
            throw new PropertyRequiredError('age')
      if (!user.name) 
            throw new PropertyRequiredError('name')

      return user
}
    
try {
      readUser('{ "name": "k", "age": 25 }')
} catch (error) {
      if (error instanceof ReadError)
            console.log(`${error.name}: ${error.cause}`)
      else 
            throw error
}


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
4.   Функции для работы с cookie
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

function getCookie(name) {
      let matches = document.cookie.match(new RegExp(
            '(?:^|; )' + name.replace(/([\.&?*|{}\(\)\[\]\\\/+^])/g, '\\$1') + '=([^;]*)'
      ))

      return matches ? decodeURIComponent(matches[1]) : undefined
}

function setCookie(name, value, options) {
      let updatedCookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`
      if (options.expires instanceof Date) 
            options.expires = options.expires.toUTCString()

      for (let optionKey in options) {
            let optionValue = options[optionKey]
            updatedCookie += `; ${optionKey}`
            if (optionValue !== true) 
                  updatedCookie += `= ${optionValue}`
      }

      document.cookie = updatedCookie
}

function deleteCookie(name) {
      setCookie(name, '', { max-age: -1 })
}


\\\\\\\\\\\\\\\\\\\\\\
5.   Длинные опросы
\\\\\\\\\\\\\\\\\\\\\\

!!! Сервер должен поддерживать много ожидающих соединений

async function subscribe() {
      let response = await fetch(url)
      if (response.status === 200) {
            let message = await response.text()
            showMessage(message)
            await subscribe()
      } else if (response.status === 502) {
            await subscribe()
      } else {
            showMessage(response.statusText)
            await new Promise(resolve => setTimeout(resolve, 1000))
            await subscribe()
      }
}


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
6.   Работа с файловой системой (node:fs) через Promise
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

const path = require('path')
const filePath = path.resolve(__dirname, 'file.txt')

      1. Современный способ

const fsPromise = require('fs/promises')

fsPromise.writeFile(filePath, 'some text')
.then(() => fsPromise.appendFile(filePath, '\nHello World!'))
.then(() => fsPromise.readFile(filePath, { encoding: 'utf-8' }))
.then(() => fsPromise.rm(filePath))
.catch((error) => console.log(error))

      2. Старый способ

const fs = require('fs')

async function writeFileAsync(path, data) {
	return new Promise((resolve, reject) => fs.writeFile(path, data, (error) => {
		if (error) return reject(error.message)
		else resolve()
	}))
}
async function appendFileAsync(path, data) {
	return new Promise((resolve, reject) => fs.appendFile(path, data, (error) => {
		if (error) reject(error.message)
		else resolve()
	}))
}
async function readFileAsync(path) {
	return new Promise((resolve, reject) => fs.readFile(path, { encoding: 'utf-8' }, (error, data) => {
		if (error) reject(error.message)
		else resolve(data)
	}))
}
async function removeFileAsync(path) {
	return new Promise((resolve, reject) => fs.rm(path, (error) => {
		if (error) reject(error.message)
		else resolve()
	}))
}

writeFileAsync(filePath, 'some text')
	.then(() => appendFileAsync(filePath, '\nHello'))
	.then(() => appendFileAsync(filePath, ' World!'))
	.then(() => readFileAsync(filePath))
	.then((data) => console.log(data))
	.then(() => removeFileAsync(filePath))
	.catch(error => console.log(error))


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
7.  Метод concat для TypedArray
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

function concatTypedArrays(arrayOfTypedArrays, resultType) {
      let result = null	
	let offset = 0
	const resultLength = arrayOfTypedArrays.reduce(
            (accum, curr) => accum.length + curr.length)

	if (resultType === 'Uint8Array') 
            result = new Uint8Array(resultLength)
	
	for (let typedArray of arrayOfTypedArrays) {
		result.set(typedArray, offset)
		offset += typedArray.length
	}

	return result
}
    
const arr = [new Uint8Array(4), new Uint8Array(8), new Uint8Array(16), new Uint8Array(32)]
console.log(concatTypedArrays(arr, 'Uint8Array')) # Uint8Array(60)


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
8.  Получение данных из ReadableStream
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

      1. Простой способ
      
async function fetchStream(readableStream) {
      const chunks = []

      for await (let chunk of readableStream)
            chunks.push(chunk)

      return concatTypedArrays(chunks, 'Uint8Array') // Нужно декодировать
}

      2. Гибкий способ

async function fetchStream(readableStream) {
	const reader = readableStream.getReader()
	const chunks = []
	let result = null

	do {
		result = await reader.read()  
		if (!result.done) 
                  chunks.push(result.value)
	} while (!result.done)
      
	reader.releaseLock() // Разблокировать поток, если он еще где-то нужен

	return concatTypedArrays(chunks, 'Uint8Array') // Нужно декодировать
}