\\\\\\\\\\\\\\\\\
1.   ЗАПОМНИТЬ   
\\\\\\\\\\\\\\\\\

>>  Для хранения number выделяется 64 бита: 52 - для чисел, 11 - для положения десятичной точки, 1 - для знака

>>  Object.is(NaN, NaN)   // true
>>  Object.is(0, -0)      // false
>>  NaN === NaN           // false
>>  null == undefined     // true   // Равны друг другу и не равны любому другому значению
>>  null > 0              // false  
>>  null == 0             // false  
>>  null >= 0             // true   
>>  undefined > 0         // false  // undefined преобразуется в NaN
>>  'some' > 'string'     // false  // Строки сравниваются посимвольно

>>  1 / 3                 // 0.3333333333333333
>>  10 / 3                // 3.3333333333333335 (округляет до ближайшего возможного согласно формату IEEE 754)
>>  NaN ** 0              // 1
>>  1 / 0                 // Infinity
>>  1 / 4                 // 0.25
>>  "str" / 2             // NaN (При любых математических операциях со строками вернет NaN, кроме +)
>>  1 + NaN               // NaN
>>  1 + '2'               // '12'
>>  '2' - 1               // 1
>>  true + false          // 1
>>  true + true           // 2
>>  undefined + undefined // NaN
>>  null + null           // 0
>>  NaN + NaN             // NaN
>>  [] + []               // '' (пустая строка)

>>  typeof(Math)          // object 
>>  typeof(null)          // object
>>  typeof(alert)         // function

>>  String(true)          // "true"
>>  String(null)          // "null"
>>  String(undefined)     // "undefined"

>>  Number(undefined)     // NaN
>>  Number(null)          // 0

>>  Boolean('0')          // true
>>  Boolean('')           // false
>>  Boolean(NaN)          // false
>>  Boolean(null)         // false
>>  Boolean(undefined)    // false

>> a ^ b ^ b === a
>> ~n === -(n + 1)
>> ' a << n ' === a * 2**b
>> ' a >> n ' === a / 2**b (крайний-левый бит (знак числа) не меняется)

>>  Область видимости `var` ограничивается функцией
>>  if (false) var phrase - переменная phrase создасться, поскольку объявления var всплывают в начало фу-и
>>  == и Boolean() используют разные правила приведения типов

>>  Полифил - аналог метода в спецификации, который не поддерживается в более старой версией движка
>>  Инкапсуляция - разделение интерфейса на внутренний и внешний


\\\\\\\\\\\\\\\\\\\\\\\\\\\\
2.   Основные типы данных   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\

      1. Number (спец. числовые значения: Infinity, -Infinity, NaN)                     

      2. BigInt (для работы с целыми числами произвольной длинны; добавить n в конце числа)

      3. String

      4. Boolean

      5. Null         

      6. Undefined

      7. Symbol

      8. Object

>> Виды записей переменных:
      1. PascalCase - типы и классы
      2. DB_PASSWORD - константные значения
      2. camelCase - все остальное
  
>> Унарный ' + ' не работает с BigInt числами

>> Ṩ === 'S\u0307\u0323' (Ṩ === S + точка сверху + точка снизу)


\\\\\\\\\\\\\\\\\\\\\\\\\\\\
3.   Преобразование типов   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\

      1.  Строковое (String(value))
      2.  Числовое (Number(value), '6' / '2' = 3)
      3.  Логическое (Boolean(value))


\\\\\\\\\\\\\\\\\
4.   Операторы   
\\\\\\\\\\\\\\\\\

- унарные
- бинарные
- сравнения
- логические


++value   > возвращает новое значение

value++   > возвращает старое значение

==        > преобразуют операнды к числу

===       > проверяет равенство без приведения типов

||        > возвращает первое истинное значение, либо последнее при всех false

||=       > Логическое присваивание ИЛИ - если операнд слева falsy, то ему присваивается операнд справа

&&        > возвращает первое ложное значение, либо последнее при всех true

&&=       > Логическое присваивание И - если операнд слева truthy, то ему присваивается операнд справа

??        > Оператор нулевого слияния (Nullish coalescing operator) - возвращает первый аргумент,
            если он не null/undefined. Запрещено использовать с && и ||
            result = a ?? b - эквивалент записи - result = (a !== null && a !== undefined) ? a : b

??=       > Оператор нулевого присваивания - если операнд слева undefined/null, то ему присваивается операнд справа

?.        > Оператор опциональной последовательности 
            (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining)


>> Побитовые операторы работают с 32-битными целыми со знаком, старшим битом слева и дополнением до двойки:
      - страший бит слева - от большего разряда к меньшему
      - дополнение до двойки - в отрицательных числах биты противоположны положительным числам и добавлена 1

>> obj.method() - оператор . возвращает Reference Type (ссылочный тип), который передает оператору () информацию о this.
      Если оператор . используется в каком-либо выражении отдельно от оператора (), то Reference Type теряет исходный this.
      Одним из решений данной проблемы является метод bind().

>> Оператор Spread - копирует собственные перечисляемые свойства объекта (без прототипа) в новый объект:
      let obj = { a: 1, b: 2 }
      let newObj = { ...obj }


\\\\\\\\\\\\\
5.   Циклы   
\\\\\\\\\\\\\

>> Циклы игнорируют СИМВОЛЬНЫЕ и НЕПЕРЕЧИСЛИМЫЕ свойства объектов

>> Директивы break/continue поддерживают метки, чтобы выйти из любого уровня вложенности циклов:
      labelName: for (...) {
        ...
        break/continue labelName;
      }


\\\\\\\\\\\\\\\
6.   Функции   
\\\\\\\\\\\\\\\

      1. Function Declaration                          : function foo() {} 
            > В Lexical Environment инициализируется мгновенно и полностью
      
      2. Function Expression                           : let foo = function() {} 
            > Не имеет        this
            > Не имеет        super
            > Не имеет        "arguments"
            > Не могут        быть вызваны с new

      3. Named Function Expression (NFE)               : let foo = function bar() {} 
            > Function Expression с именем;
            > Для рекурсивных вызовов;
            > Недоступна за пределами фу-и.

      4. new Function([arg1, ..., argN], functionBody) : let foo = new Function('a', 'b', 'return a + b')
            > Имеет [[Environment]], ссылающийся на глобальное лексическое окружение.

      5. Tagged Template String Literal (теговый шаблон) - tag`first str ${arg1} and ${arg2} third str`.
            > function tag(strings, ...expressions) {} 
                  > strings       - массив строк между ${expression}.
                  > expressions   - массив выражений ${expression}.
                  > strings.raw() - исходная строка.


>> new.target - исп. внутри фу-и, чтобы проверить вызвана ли фу-я при помощи new
>> isNaN() и isFinite() отличаются от Number.isNaN() и Number.isFinite()
>> Object.is() идентичен === , кроме 2-х случаев
>> parseInt('100px', 10) === 100
>> str.codePointAt(pos) // код символа на позиции pos
>> String.fromCodePoint(code)
>> foo.name - имя фу-и
>> foo.length - ко-во аргументов в объявлении фу-и. Остаточные параметры не считаются
>> call  - принимает список аргументов
>> apply - принимает псевдомассив
>> bind  - возвращает экзотический объект bound function, который фиксирует контекст и аргументы только во время создания
>> [].join.call(arguments) // пример заимствования метода с помощью call
>> window.eval(str) - выполняет строку кода str и возвращает результат последнего line. 
                      При `use strict` имеет свое lexical environment.


>> Контекст выполнения - спец. внутренняя структура данных, которая содержит информацию о вызове фу-и 
    (место логического курсора, локальные переменные фу-и, значение this и пр.)

>> Применение рекурсии:
      - рекурсивные обходы (объект в объекте в объекте...)
      - рекурсивные структуры (связанный список)

>> arguments - подобный массиву объект содержащий ВСЕ переданные в фу-ю аргументы, не поддерживает методы массивов. 

>> Lexical Environment - объект спецификации: он описан в спецификации для описания того, 
                         как все работает, его нельзя получить

>> Переменная - свойство спец. внутр. объекта Environment Record (хранилище переменных).
                Поиск искомой переменной происходит сначала во внутреннем Lexical Environment, 
                затем во внешнем, и так до глобального объекта

>> Вложенный setTimeout гарантирует фиксированную задержку после выполнения фу-и

>> Браузер ограничивается 4 мс минимальной задерожки между более 4 вызовов setTimeout или setInterval

>> Декораторы (Decorators) - обертка вокруг фу-и, которая изменяет ее поведение

>> Частичное применение - создание новой фу-и с некоторыми фиксированными аргументами (double = multiple.bind(null, 2))

>> Каррирование - трансформация фу-и из f(a,b,c) в f(a)(b)(c). 
                  Можно создавать частично-примененные фу-и (т.к. каждый аргумент запоминает свою обл. видимости).
                  Только для фу-й с фиксированным количеством аргументов.


\\\\\\\\\\\\\\\
7.   Объекты    
\\\\\\\\\\\\\\\

>> null и undefined НЕ имеют объектов-оберток. У них нет свойств, методов, прототипов.

>> Все ключи объектов преобразуются в строки (кроме символов и строк).

>> this - указывает на объект перед точкой.

>> ?. - опциональная цепочка (optional chaining) - останавливает вычисление и возвращает undefined,
        если значение слева === undefined или === null 
        - работает только с объявленными объектами
        - работает только для ЧТЕНИЯ и УДАЛЕНИЯ
        - работает для вызова фу-и, которой может не существовать ( obj.method?.() )
        - работает для объектов со свойствами в квадратных скобках ( obj?.[prop] )

>> [Symbol.iterator]() {} - спец. метод объекта для настройки итерации объекта "вручную". 
                            Возвращает объект с методом next(), который вызывается на каждой итерации.

>> Варианты преобразования типов (хинты): 1. "string"
                                          2. "number"
                                          3. "default"

>> [Symbol.isConcatSpreadable]: true - спец. свойство объекта, которое указывает методу array.concat(obj) обрабатывать obj как массив.
                                       * Пример:
                                                let array = [1, 2]
                                                let obj = { 0: 'someValue', 1: 'anotherValue' }
                                                ( array.concat(obj) ) // 1, 2, someValue, anotherValue

>> [Symbol.toStringTag]: 'Value' - спец. свойство объекта для настройки toString у объектов.
                                   Это свойство есть у большей части встроенных объектов.
                                   Результат === значение этого свойства обернутое в [object Value].

>> Дескриптор свойства - объект, который содержит значение и флаги (атрибуты) свойства.
>> Атрибуты дескриптора для data properties: 
      - value 
      - writable        === false, value нельзя изменить
      - enumerable      === false, свойство игнорируется циклом, Object.keys
      - configurable    === false, нельзя удалить, нельзя изменить значение всех атрибутов с false на true

>> Object.getOwnPropertyDescriptor(obj, propName)       - возвращает дескриптор свойства.
>> Object.getOwnPropertyDescriptors(obj)                - возвращает объект, содержащий дескрипторы всех свойств.
>> Object.defineProperty(obj, propName, descriptor)     - возвращает obj.
>> Object.defineProperties(obj, { prop: descriptor })   - возвращает obj.
>> let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj)) - клонирование объекта вместе с флагами.

>> Типы свойств:
      - Data properties (свойства-данные)
      - Accessor properties (свойства-аксессоры) 

>> Accessor properties - фу-и, которые исп. для получения и присвоения значения, но синтаксически выглядит как свойство объекта.
      let obj = {
            get propName() {}       - срабатывает при чтении obj.propName
            set propName(value) {}  - срабатывает при записи obj.propName = value 
      }
  
>> Атрибуты дескриптора для accessor properties:
      - get            // { get() { return this.name } }
      - set            // { set(value) { this.name = value } }
      - enumerable
      - configurable


>> Intl - объект c API интернационализации:
      > let collator  = Intl.Collator([locales, [options]])
      > let formatter = Intl.DateTimeFormat([locales, [options]])
      > let formatter = Intl.NumberFormat([locales, [options]])

>> Сильная ссылка - ссылка на объект, которая предотвращает его удаление сборщиком мусора.
>> Слабая ссылка  - ссылка на объект, которая НЕ предотвращает его удаление сборщиком мусора.
  
>> new WeakRef(target) - объект, содержащий слабую ссылку на target.
>> new FinalizationRegistry(cleanuCallback) - объект, который позволяет привязять к target колбэк очистки, 
                                                который выполниться после удаления target из памяти сборщиком мусора.


\\\\\\\\\\\\\\\\\
8.   Прототипы   
\\\\\\\\\\\\\\\\\

>> [[Prototype]] - скрытое свойство, либо === null, либо ссылается на другой объект - прототип
      - Замена [[Prototype]] в существующих объектах ОЧЕНЬ медленная операция ( Object.setPrototypeOf и obj.proto = )

>> obj.__proto__ - это getter/setter для [[Prototype]], то есть способ доступа до

>> Операции запись/удаление не работают с прототипом (за исключением свойства-аксессора setter)

>> this - указывает на объект перед точкой

>> Циклы учитывают унаследованные свойства
>> Object.keys, Object.values и др. - игнорируют унаследованные свойства

>> Foo.prototype = {}/null - определяет __proto__ только для экземпляров new Foo
      function Foo() {} > Foo.prototype = obj2 > let obj1 = new Foo() > obj.__proto__ === obj2
>> Foo.prototype === { constructor: Foo }
>> obj.__proto__ === arr.__proto__.__proto__ === func.__proto__.__proto__ === Number(5).__proto__.__proto__ === Object.prototype

>> obj.join = Array.prototype.join // пример заимствования метода с помощью prototype

>> Вместо __proto__ : 1. Object.create(proto, [descriptor])       // создает {} со свойством [[Prototype]] и дескриптором
                      2. Object.getPrototypeOf(obj)               // возвращает [[Prototype]]
                      3. Object.setPrototypeOf(obj, proto)        // устанавлиавает [[Prototype]]

>> let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))

>> Простейший объект (ассоциативный массив) - создается через new Map / Object.create(null) / obj.__proto__ = null 

>> obj['__proto__'] = 'someValue' // присвоение проигнорируется


\\\\\\\\\\\\\\
9.   Классы   
\\\\\\\\\\\\\\

>> Класс - шаблон кода для создания объектов, который устанавливает в них начальные свойства и методы

>> [[IsClassConstructor]]: true - спец. внутр. свойство фу-и, созданной с помощью class 
>> Методы и constructor - сохраняются в SomeClass.prototype
>> Методы класса неперечисляемы
>> Классы всегда используют 'use strict'
>> (Named) Class Expression - аналог (Named) Function Expression

>> class Child extends Parent : 
      - Child.prototype.__proto__ === Parent.prototype
      - после extends разрешены любые выражения

>> super.method() - вызывает родительский метод
>> super()        - вызывает конструктор родителя (работает только в дочернем конструкторе)

>> При отсутсвии конструктора, вызывается пустой конструктор ( constructor(...args) { super(...args) } )
>> Конструкторы в дочерних классах должны обязательно вызывать конструктор родителя ( super() ) перед использованием this 
>> [[ConstructorKind]]: 'derived' - спец. внутр. свойство функции-конструктора дочернего класса.
                                    Такой конструктор ожидает вызова конструктора родительского класса,
                                    который создаст пустой объект и присвоет его this.
                                    Поэтому, если мы создаем конструктор в дочернем классе, необходимо вызвать super,
                                    иначе объект для this не будет создан и мы получим ошибку.

>> Родительский конструктор всегда использует СВОЕ ЗНАЧЕНИЕ ПОЛЯ, а не переопределенное дочерним классом
>> Поля РОДИТЕЛЬСКОГО класса инициализируются перед конструктором
>> Поля ДОЧЕРНЕГО класса инициализируются после вызова super

>> [[HomeObject]] : 
      - спец. внутр. свойство методов класса (объекта) и оно равно этому классу (объекту)
      - используется только в super, чтобы получить прототип родителя и его методы
      - нельзя изменить, поэтому копировать метод использующий super, между объектами небезопасно
      - в объектах работает только в методах объявленных как method()

>> Статические свойства и методы класса - устанавливаются самому классу:
      - наследуются дочерним классом ( Child.[[Prototype]] = Parent ) 
      - НЕ наследются от встроенных классов
      - this === сам класс ( по аналогии с объектами )
      - экземплярам класса НЕДОСТУПНЫЕ
      - СИНТАКСИС: 
            1. class MyClass {
                  static property = ...
                  static method() { ... }
            };

            2. MyClass.property = ...
               MyClass.method   = ...
              
>> Защищенные методы и свойства - по соглашению JS-программистов:
      - доступны только внутри класса
      - начинаются с префикса ' _ '

>> Приватные методы и свойства:
      - начинаются со спец. символа ' # '
      - доступны исключительно внутри класса
      - не наследуются
      - не конфликтуют с публичными
      - не работает с this ( this['#prop'] - не работает )

>> Symbol.species - спец. статический getter, который должен вернуть конструктор,
                    который будет использован для создания новых объектов:
                    * Пример: 
                        class ExtendedArray extends Array {
                              static get [Symbol.species]() { return Array }
                        }           
                        let array = new ExtendedArray(1, 2, 3, 4, 5)
                        let filteredArray = array.filter(item => item >=3)
                        ( filteredArray.__proto__ === array.__proto__ ) // false
      
>> instanceof - оператор проверяет, принадлежит ли объект указанному классу, с учетом наследования
                Алгоритм работы: 
                        1. Если в классе есть статичный метод [Symbol.hasInstance], то вызвать его ( должен возвращать true/false):
                              * Пример:
                                    class Animal {
                                          static [Symbol.hasInstance](obj) { if (obj.catEat) return true }
                                    }
                                    let obj = { catEat }
                                    ( obj instanceof Animal ) // true

                        2. Проверка на равенство прототипа класса какому либо прототипу в прототипной цепочке объекта: 
                              ( Class.prototype === obj.__proto__ )
                              ( Class.prototype === obj.__proto__.__proto__ ) и т.д.

>> objA.isPrototypeOf(objB) - аналог instanceof: ( obj instanceof Class === Class.prototype.isPrototypeOf(obj) )

>> Примеси (Mixins) - класс, методы которого предназначены для расширения функциональности других классов без наследования от примеси.
                    - Примесь необходимо скопировать в прототип расширяемого класса ( Object.assign(ClassName.prototype, mixin) )
                    - Примесь перезаписывает существующие методы класса

>> JavaScript НЕ поддерживает множественное наследование. Вместо него используют Mixins


\\\\\\\\\\\\\\\\\\\\\\\\\
10.  Тип данных Symbol  
\\\\\\\\\\\\\\\\\\\\\\\\\

      1. Symbol.for(key) 
      2. Symbol.keyFor(symbol)
      3. Object.getOwnPropertySymbols(obj)
      4. Reflect.ownKeys(obj)
      5. Symbol.toPrimitive

>> Свойства, чьи ключи Символы игнорируются циклом for...in и Object.keys()


\\\\\\\\\\\\\\\\\
11.  Замыкание   
\\\\\\\\\\\\\\\\\

>> Замыкание - это фу-я, которая с помощью скрытого свойства [[Environment]] запоминает свои внешние переменные
               и может получить к ним доступ. ( https://learn.javascript.ru/closure )
               

\\\\\\\\\\\\\\\\\\\\\\\\
12.  Обработка ошибок
\\\\\\\\\\\\\\\\\\\\\\\\

>> try {} catch() {} finally {} - работает синхронно, то есть ассинхронный код игнорируется
      - finally выполняется всегда, в т.ч. после return 
      - при возникновении ошибки JS генерирует объект ошибки и передает как аргумент в блок catch
      - catch должен обрабатывать только известные ему ошибки, а остальные пробрасывать ( throw error )

>> throw <объект ошибки> - оператор генерирующий ошибку

>> window.onerror = function (message, url, line, column, error) {} - глобальный catch

>> Сервисы для логирования ошибок:
      - https://errorception.com
      - http://www.muscula.com

>> Расширение встроенных классов ошибок:
      - class MyError extends Error
      - вызвать super
      - изменить name ( this.name = this.constructor.name - чтобы не прописывать вручную name)

>> instanceof - использовать для проверки типа ошибок (при расширении классов ошибок)

>> Обертывание исключений - алгоритм: фу-я ловит низкоуровневые исключения и создает 1 высокоуровневое
      

\\\\\\\\\\\\\\\\\\\\\
13.  Асинхронность   
\\\\\\\\\\\\\\\\\\\\\

>> new Promise(function(resolve, reject) { <executor> }).then(function(result) {}, function(error) {})
                                                        .catch(function(error) {})
                                                        .finally(function() {})

      1. executor       - фу-я-исполнитель, которая запускается сразу после создания Promise
      2. resolve(value) - встроенный callback, который необходимо вызвать при успешном выполнении executor
      3. reject(error)  - встроенный callback, который необходимо вызвать при ошибке в executor
      4. Экземпляр обладает внутренними свойствами:
            > state (состояние; может быть изменено только 1 раз): 
                  - pending   (ожидание)
                  - fulfilled (выполнено успешно)
                  - rejected  (выполнено с ошибкой)
            > result (в зависимости от state):
                  - при pending     === undefined
                  - при fulfilled   === value
                  - при rejected    === error
      5. then - возвращает Promise; then выполняет:
            > 1-й callback при state === fulfilled
                  - возвращаемое значение становится результатом выполнения Promise и передается в следующий .then 
            > 2-й callback при state === rejected
      6. catch - укороченный вариант для .then(null, function(error) {})
      7. finally - метод, который:
            > выполнится в любом случае
            > ничего не возвращает
            > пропускет result или error дальше, к следующему then/catch

            
>> Если callback в .then/.catch/.finally возвращает new Promise, последующие элементы цепочки ждут, пока выполнится new Promise

>> thenable - отличительный признак объекта содержащего метод .then, который можно вернуть как Promise.
              Если фу-я возвращает объект с пользовательским методом .then, то интерпретатор обрабатывает его
              как Promise и вызывает его метод .then, после чего передает ему встроенные resolve и reject

>> fetch - возвращает Promise, который возвращает объект response ПОСЛЕ того, как удаленный сервер присылает
           ЗАГОЛОВКИ ответа, но ДО того, как ВЕСЬ ОТВЕТ сервера полностью загружен

>> Скрытым try-catch - обладает фу-я Promise и callback - ошибки обрабатываются по ходу выполнения кода (синхронно)

>> Проброс ошибки (throw) в .catch работает аналогично пробросу в try-catch

>> 'unhandledrejection' - событие, которое срабатывает при наличии необработанных ошибок.
                          Возникает, когда все промисы (микрозадачи) завершены и какой-либо из них "rejected"
                          Основные свойства:
                              - event.promise // [object Promise] - Promise, который сгенерировал ошибку
                              - event.reason  // Объект ошибки, которая не была обработана

>> Методы класса Promise:
    1. Promise.all            - ждет, пока все переданные промисы выполнятся УСПЕШНО (или 1-ю ошибку)
    2. Promise.allSettled     - ждет, пока все переданные промисы ЗАВЕРШАТСЯ
    3. Promise.race           - ждет 1-й ЗАВЕРШЕННЫЙ промис
    4. Promise.any            - ждет 1-й УСПЕШНО выполненный промис
    5. Promise.resolve/reject - возвращает промис успешный/с ошибкой (async-await заменяет эти методы)

>> Промисификация - создание фу-и-обертки, которая принимает в качестве параметра callback
                    и возвращает Promise, который вызывает этот callback

>> PromiseJobs (mikrotask queue) - очередь микрозадач (.then/.catch/.finally попадают в очередь): 
                                   движок выполняет задачи из очереди, когда он выполнит основной код
                                    
>> async - оператор, который пишется перед объявлением фу-и, теперь эта фу-я всегда будет возвращать Promise
            - работает для методов класса
            - для обработки финального результата/ошибки использовать .then/.catch
            
>> await - оператор, который пишется перед Promise в async фу-и, теперь интерпретатор ждет, пока Promise не выполнится
            - работает с thenable-объектами
            - для обработки ошибок использовать try-catch
 
>> Условия для async-итерации:
      1. [Symbol.asyncIterator] - вместо [Symbol.iterator]
      2. next() - должен возвращать Promise
      3. Для итерации по объекту исп. только for await


\\\\\\\\\\\\\\\\\\
14.  Генераторы
\\\\\\\\\\\\\\\\\\

>> function* generateSequence() {         // при вызове возвращает спец. объект - генератор ( [object Generator] )
      yield 1
      yield 2
      return 3 // <!>
   }
   let generator = generateSequence()     // перебираемый объект ( <!> цикл не возвращает значение return )
   generator.next()                       // выполняет код фу-и до ближайшей инструкции ' yield ', после чего останавливается.
                                                Возвращает объект: 
                                                      { value: 'value', done: true/false }
                                                            - true в случае завершения выполнения фу-и ( или return )
      
>> Генераторы можно генерировать бесконечно ( например, с помощью цикла в теле функции-генератора )

>> Для создания перебираемых объектов обычно исп. генератор  - *[Symbol.iterator]
>> *[Symbol.iterator]() {} - сокращенная запись для [Symbol.iterator]: function* () {} 
      
>> yield* - инструкция, которая делегирует выполнение другому генератору
>> Композиция генераторов - возможность встраивать генераторы друг в друга с помощью инструкции ' yield* '
                            * Пример: 
                                    function* generateSequnce(start, end) {
                                          for (let i = start; i !== end; i++) yield i
                                    }
                                    function* generateAnotherSequence() {
                                          yield* generateSequence(1, 5)
                                          yield* generateSequence(5, 10)
                                    }

>> yield и next могут обмениваться значениями:
      - yield передает значение объекту, который возвращает текущий ' next '
      - next(arg) передает arg в генератор, после чего arg становиться результатом предыдущего выражения yield
            * Пример: 
                    console.log(yield 1) // generator.next().value  === 1           // в консоле выведет 4
                    console.log(yield 2) // generator.next(4).value === 2           // в консоле выведет 9
                    console.log(yield 3) // generator.next(9).value === 3           // в консоле выведет 16
                                         // generator.next(16).value === undefined

>> throw - метод инициирующий ошибку на последнем сработавшем yield (generator.throw(new Error()))
       
>> Async-генератор:
      - необходимо добавить async
      - next возвращает Promise 
      - перебирать генератор только с помощью for await 

>> Для создания async-перебираемых объектов обычно исп. async-генератор - async *[Symbol.asyncIterator]


\\\\\\\\\\\\\\
15.  Модули
\\\\\\\\\\\\\\

>> Модуль - файл со скриптом

>> export - отмечает переменные и фу-и, которые должны быть доступны вне модуля
>> import - импортирует функциональность из других модулей

>> Свойства модулей:
      1. В модуле всегда используется режим 'use strict'
      2. Каждый модуль имеет свою обл. видимости
      3. Импортируемый код выполняется 1 раз
      4. Изменения импортируемых данных видят все импортеры
      5. В модуле this === undefined ( в не-модуле this === window )
      6. Модули выполняются в отложенном режиме ( deferred ):
            - модули ожидают полной загрузки HTML
            - сохраняется порядок выполнения скриптов в документе
      7. Модули с одинаковым src выполняется 1 раз
      8. Модуль загружаемый с другого домена требует указания заголовков CORS

>> Рекомендуется явно указывать список импортируемого функционала - для легкой поддержки кода 

>> export default - экспорт по умолчанию: 
      - в модуле может быть только 1 такой экспорт
      - при импорте такого экспорта {} не нужны
      - экспортируемая сущность не обязана иметь имя
      - export { foo as default } - экспорт отдельно от объявления
      - при import * as foo, доступ к export default через foo.default

>> export ... from ... - реэкспорт:
      - позволяет импортировать функционал и одновременно его экспортировать 
      - исп. для возможности импортировать весь функционал из 1 "главного" файла

>> export { default } from ... - реэкспорт по умолчанию

>> import 'module' - запустит код импортируемого модуля

>> import('module') - динамический импорт:
      - загружает модуль и возвращает Promise
      - можно исп. в любом месте кода
      - работает в скрипте не-модуле
      - внутри async фу-и можно исп. await import('module')
      - это НЕ фу-я ( аналог super() )


\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16.  Регулярные выражения
\\\\\\\\\\\\\\\\\\\\\\\\\\\\

>> Создание regexp:
      a. let regexp = new RegExp('шаблон', 'флаги')       // можно использовать переменные
      b. let regexp = /шаблон/флаги                       // только статичный текст
    
>> Флаги:
      i - поиск не зависит от регистра
      g - поиск ищет ВСЕ совпадения (иначе только первое)
      m - многострочный режим (только для якорей ^ и $, чтобы искать в каждой строке разделённых переносом строки \n)
      s - режим dotall ( . === /n)
      u - полная поддрежка Юникода
      y - поиск на конкретной позиции в тексте
      d - результат помещается в массив

>> Символьные Классы:
      \d - цифра (0-9)
      \s - пробельные символы
      \w - буквы латинского алфавита, цифры, _
      \p{...} - юникодные свойства, работает только с флагом u, описывают категорию символа: L, N, P, и т. д. 
            "123 test".match(/\p{L}/gu) === t,e,s,t
      .  - любой символ, кроме \n (с флагом s будет учитывать и \n)
      ^ - начало строки
            /^\d/.test("1. Test") === true
      $ - конец строки
            /st$/.test("2. Test") === true
      ^...$ - полное совпадение строки
            /^test$/.test("test") === true
      \b...\b - ищет слово (начинается на \w, заканчивается не \w)
            "JavaScript Java Script".match(/\bJava\b/g) === Java
      [...] - искать один символ соответствующий какому-либо из переданных (диапазону) символов, символьных классов
      [^...] - искать любые символы кроме указанных
            "abc".match(/[abc])    === a
            "abc".match(/a[a-z]/)  === ab
            "1bc".match(/[^0-9]+/) === bc
      | - альтернация, как [...], но работает не с символами, а с любыми выражениями
            "00:00 10:10 23:59 25:99 1:2".match(/([01]\d|2[0-3]):[0-5]\d/g) === 00:00, 10:10, 23:59

>> Квантификаторы - пишутся после символа, который нужно искать какое-то число раз
      + - 1 и более раз
      * - 0 и более раз
      ? - 0 или 1 раз
      {n} - n раз (после n через кому можно указать дополнительное число раз: {1,2} - 1 или 2 раза)

>> Обратный Символьный Класс - класс, который исключаюет другой соответствующий класс (Например: \D, \S, \W)

>> Методы:
      str.match(regexp) - ищет совпадения 
            - без скобочных групп
            - если совпадений нет, возвращает null

      str.matchAll(regexp) - ищет совпадения
            - со скобочными группами
            - возвращает перебираемый объект (Array.from, чтобы сделать из него массив)
            - если совпадений нет, возвращает пустой перебираемый объект

      str.replace(str|regexp, str|function) - универсальный метод поиска и замены в строке
            - во 2-м аргументе (строка замены) можно использовать спец. символы (см. Подстановки)
            - во 2-м аргументе может быть фу-я - её результат будет вставлен в качестве замены
                  > func(match, p1, ..., pn, offset, input, groups)
                        1. match - найденное совпадение
                        2. p1, ..., pn - содержимое скобочных групп
                        3. offset - позиция, на которой найдено совпадение
                        4. input - исходная строка
                        5. groups - объект с содержимым именованных скобочных групп

    
      str.split(regexp|substr, limit) - разбивает строку по разделителю regexp или substr
      str.search(regexp) - возвращает позицию 1-го совпадения или -1, если совпадений нет                 

      regexp.exec(str) - аналогичен str.match(regexp)
            > при наличии флага g
                  - regexp.lastIndex - позиция начала поиска каждого следующего совпадения
                  - если совпадений больше нет, то regexp.exec(str) возвращает null, а regexp.lastIndex === 0
            > при наличии флага y
                  - regexp.lastIndex - ищет исключительно на позиции lastIndex

      regexp.test(str) - если есть хоть одно совпадение, то возвращает true, иначе false
            !!! имеется свойство regexp.lastIndex
            !!! после использования lastIndex меняется на следующий

>> Для поиска символов [ ] \ ^ $ . | ? * + ( ) необходимо их экранировать

>> Символьные классы - сокращение для наборов символов:
      \d === [0-9]
      \w === [a-zA-Z0-9_]
      \s === [\t\n\v\f\r]

>> Режимы квантификаторов:
      1. Жадный  - повторяет квантификатор максимальное число раз. 
            Если строка закончилась, поиск возвратится до ближайшего совпадения оставшегося шаблона.
            Режим работает по умолчанию.
      2. Ленивый - ищет совпадения для оставшегося шаблона перед каждым повторением квантификатора.
            Режим включается знаком ? после квантификатора.

>> Скобочная группа:
      1. Квантификаторы применяются ко всему содержимому скобок
      2. Скобочные группы поочередно сохраняются в результируюющий массив (номерация начинается с 1):
            - не работает с флагом g
            - если скобочная группа необязательна (квантификатор ?), она все равно будет в результате как undefined
      3. str.matchAll(regexp):
            - возвращает перебираемый объект (Array.from(obj), for (let array of obj), [array1, array2] = obj)
            - с флагом g каждое совпадение это массив со скобочными группами
            - если совпадений нет, возвращает пустой перебираемый объект
      4. (?<name>...) - именование скобочной группы
            - именованные группы находятся в array.groups
      5. str.replace(regexp, replacement) - в строке замены replacement можно использовать содержимое скобочных групп:
            - по номеру скобочной группы ( $n )
                  >> 'aaa bbb'.replace(/(\w+) (\w+)/, '$2 $1') === 'bbb aaa'
            - по имени скобочной группы ( $<name> )
                  >> 'a b'.replace(/(?<name1>a) (b)/, '$name1 $name1') === 'a a'
      6. ?: - исключает содержимое скобочной группы из результата
            >> 'a b'.match(/(?:\w) (\w)/)
    
>> Обратные ссылки в шаблоне (доступ к скобочным граппам в шаблоне):
      \number - по номеру скобочной группы
      \<name> - по имени скобочной группы

>> Подстановки (шаблон замены - метод replace):
      $$ - подставляет знак $
      $& - подставляет совпадение полностью 
      $n - подставляет совпадение группы под номером n
      ${name} - подставляет совпадение группы с именем name

>> Проверки:
      - при нескольких проверках подряд для совпадения необходимо выполнение всех проверок
      - чтобы Y был в результате, его необходмо обернуть в скобки
            X(?=Y) - ищет X, если за ним Y
            X(?!Y) - ищет X, если за ним НЕ Y
            (?<=Y)X - ищет X, если перед ним Y
            (?<!Y)X - ищет X, если перед ним НЕ Y


\\\\\\\\\\\
17.  DOM
\\\\\\\\\\\

>> Свойства и методы:
+ Свойства узлов
      elem.nodeType           - тип узла. [number, read only].
      elem.tagName            - имя тега элемента. [read only].
      node.nodeName           - имя/тип узла. [read only].
      elem.innerHTML          - HTML-содержимое элемента.
      elem.outerHTML          - HTML-элемент. Изменятся элемент в DOM, но не содержимое переменной.
      textNode.data/nodeValue - содержимое ТЕКСТОВОГО узла.
      elem.textContent        - текст внутри элемента.
      
+ HTML-атрибуты
      elem.hasAttribute(name)        - проверить наличие атрибута.
      elem.getAttribute(name)        - получить значение атрибута.
      elem.setAttribute(name, value) - установить значения атрибута.
      elem.removeAttribute(name)     - удалить атрибут.
      elem.attributes                - коллекция атрибутов в виде объектов со свойствами name и value.

+ Поиск элементов:
      elem.matches(css)          - проверяет удовлетворяет ли элемент селектору CSS. [true/false].
      elem.closest(css)          - ищет ближайшего предка, включая сам элемент.
      elemA.contains(elemB)      - true, если elemB внутри elemA или elemA === elemB, иначе false.
      elem.querySelector(css)    - находит первый подходящий элемент.
      elem.querySelectorAll(css) - находит все подходящие элементы.
      elem.getElementById(id)    - находит элемент по id.
      elem.getElementsByClassName(class) -┐
      elem.getElementsByTagName(tag) -----|--> возвращают коллекцию, которая обновляется при изменениях.
      elem.getElementsByName(name) -------┘

+ Создание и изменения узлов
      document.createElement(tag)     - создать элемент с заданным тегом.
      document.creatTextNode(text)    - создать текстовый узел с заданным текстом.
      node.prepend(node | string)     - добавить узел в начало.
      node.append(node | string)      - добавить узел в конец.
      node.before(node | string)      - добавить узел перед узлом.
      node.after(node | string)       - добавить узел после узла.
      node.replaceWith(node | string) - заменить узел на заданный узел.
      node.remove()                   - удалить узел.
      node.cloneNode(true | false)    - возвращает клон элемента с/без дочерними элементами.
      insertAdjacentHTML(where, html)       - вставляет html    | where:
      insertAdjacentText(where, string)     - вставляет текст   |  beforebegin/afteend  - до/после элемента.
      insertAdjacentElement(where, element) - вставляет элемент |  afterbegin/beforeend - начало/конец элемента.

+ Стили и классы
      elem.style - спец. объект стилей. Имена свойств CSS в JS преобразуются по принципу: дефис -> большая буква.
!!!>               Оперирует только атрибутом style в HTML, не имеет доступа к стилям из <style> и файлов CSS.
      elem.style.cssText - строка, содержащая ассоциативный массив CSS. 'prop1: value1; prop2: value2;'
      elem.className     - строка с набором всех классов через пробел. 'class1 class2 class3'
      elem.classList     - перебираемый объект, содержащий список и методы добавления/удаления классов.
      elem.classList.add(string)      - добавить класс.
      elem.classList.remove(string)   - удалить класс.
      elem.classList.toggle(string)   - добавить класс, если его нет, удалить - если есть.
      elem.classList.contains(string) - проверяет наличие класса. [true/false].
      elem.style.anyProperty = "" - присвоить свойству пуйстую строку, чтобы сбросить стиль (вместо удаления).
      getComputedStyle(element, [pseupo]) - возвращает объект с вычисленными стилями.
                                            Аналог elem.style, но с учётом <style> и файлов CSS.
                                            Значения свойств всегда в абсолютных величинах (пиксели).
                                            Содержит только полные значения (paddingTop, но не padding).
                                            Не даёт доступа к псевдоклассу :visited.

+ Размеры и прокрутка элементов
      elem.getBoundingClientRect() - возвращает объект, содержащий координаты elem.
      document.elementFromPoint(x, y) - возвращает самый глубоко вложенный элемемент в окне по координатам.
      elem.offestParent - ближайший позиционированный предок элемента. null для элементов position: fixed.
      elem.offsetLeft/offsetTop - координаты относительно левого верхнего угла offsetParent. (read only).
      elem.offsetWidth/offsetHeight - ширина/высота элемента включая border. (read only).
      elem.clientLeft/clientTop - отступы внутренней части элемента от внешней (часто равны border). (read only).
      elem.clientWidth/clientHeight - контент + padding, без прокручиваемой области. (read only).
      elem.scrollWidth/scrollHeight - контент + padding, и вся прокручиваемая область. (read only).
      elem.scrollLeft/scrollTop - ширина/высота уже прокрученного контента.
!!!>  Не стоит брать width/height из CSS.
      document.documentElement.clientWidth/clientHeight - ширина/высота окна, за вычетом полосы прокрутки.
      window.innerWidth/innerHeight - ширина/высота окна браузера вместе с полосой прокрутки.
      window.pageXOffset/pageYOffset -| ширина/высота прокрученной области страницы.
      window.scrollX/scrollY ---------┘
      window.scrollBy(x, y) || (options) - прокручивает страницу ОТНОСИТЕЛЬНО её текущего положения. 
      window.scrollTo(x, y) || (options) - прокручивает страницу на АБСОЛЮТНЫЕ координаты. 
                                options === {
                                    top: x,
                                    left: y,
                                    behavior : "auto"||  "instant" || "smooth"
                                };
      elem.scrollIntoView(top) || (options) - прокручивает страницу так, чтобы elem находился вверху/внизу 
                                   options === {                                         (top = true/false).
                                          behavior:  "auto" || "instant" || "smooth",
                                          block: "start" || "center" || "end" || "nearest",
                                          inline: "start" || "center" || "end" || "nearest"
                                   };
!!!>  Получить полную высоту документа:
            let scrollHeight = Math.max(
                  document.body.scrollHeight, document.documentElement.scrollHeight,
                  document.body.offsetHeight, document.documentElement.offsetHeight,
                  document.body.clientHeight, document.documentElement.clientHeight
            );
      document.body.style.overflow = 'hidden' - делает документ не прокручиваемым, но исчезает полоса прокрутки.

+ Устаревшие методы и свойства
      parentElem.appendChild(node)               - добавить node в конец parentElem.
      parentElem.insertBefore(node, nextSibling) - добавить node перед nextSibling.
      parentElem.replaceChild(node, oldChild)    - заменить oldChild на node.
      parentElem.removeChild(node)               - удалить node.
      document.write(html) - во время загрузки страницы на ходу записывает в неё HTML (работает очень быстро).
                             Если вызвать после окончания загрузки страницы, её содержимое затрётся. 

>> Наборы ссылок:
      > Для всех узлов: childNodes, parentNode, firstChild, lastChild, previousSibling, nextSibling.
      > Для элементов: children, parentElement, firstElementChild, lastElementChild, previousElementChild, nextElementChild.

>> DOM-узлы представляют собой обычные объекты соответствующих классов.
   Классы DOM описываются в Interface Description Language (IDL).
   Пример классов DOM:
      1. EventTarget
      2. Node
      3. Element
      4. HTMLElement и т.п.

>> Особенности HTML-атрибутов:
      > Стандартные атрибуты в HTML-элементах соответствуют свойствам этих элементов в JS-коде.
      > HTML-атрибуты регистронезависимы и их значения всегда строки.
      > Значение некоторых HTML-атрибутов нельзя изменить в JS-коде.
      > data-атрибуты доступны в свойстве элемента dataset: 
            HTML: <a data-foo-bar="value"> ---> JS: a.dataset.fooBar

>> DocumentFragment - класс, позволяющий создавать обёртку вокруг набора узлов.
                      Когда обёртку куда-либо применяют, она исчезает и остаётся только её содержимое.


\\\\\\\\\\\\\\\
18.  События
\\\\\\\\\\\\\\\

>> Способы назначить обработчик событий:
      1. Атрибут элемента on<имясобытия>
      2. Свойство элемента on<имясобытия>
      3. elem.addEventListener(event, handler, [options]):
            > event - имя события
            > handler - ссылка на функцию, или объект/экземпляр класса с методом handleEvent(event) {}
            > options === 1. true/false - фаза срабатывания обработчика: погружение/всплытие
                          2. {
                                    once: true/false    - после выполнения обработчик удалить/неУдалять
                                    capture: true/false - фаза срабатывания обработчика: погружение/всплытие
                                    passive: true/false - если true, то сообщает браузеру, что обработчик не вызовет
                                                          preventDefault(), и браузер сразу выполнит действие по умолчанию, 
                                                          не ожидая других обработчиков.
                              }

> elem.removeEventListener(event, handler, [options]) - удаляет обработчик события handler (нужна та же фаза).
> event.preventDefault() - отменить действие браузера по умолчанию.
> event.defaultPrevented - если true, то событие по умолчанию отменено (лучше чем event.stopPropagation()).
> event.stopPropagation() - останавливает всплытие дальше.
> event.stopImmediatePropagation() - предотвращает всплытие включая текущий элемент.
> event.eventPhase - фаза, на которой сработал обработчик (погружение = 1, фаза target = 2, всплытие = 3).
> event.currentTarget === this - элемент, на котором в данный момент выполняется обработчик (меняется по мере всплытия).
> event.target - самый глубоко вложенный элемент, на котором сработал слушатель (не изменнен в процессе всплытия).
> event.buttons - возвращает номер кнопки мыши (0 - левая, 1 - средняя, 2 - правая и т.д.).
> event.clientX/clientY/pageX/pageY - | координаты курсора относительно окна/документа

>> События клавиатуры:
      > 'keydown' - срабатывает при нажатии клавиши
      > 'keyup'   - срабатывает при отпускании клавиши

>> Автоповтор - при долгом нажатии клавиши, событие 'keydown' срабатывает повторно, пока не сработает 'keyup'.
>> event.repeat === true - для событий вызванных автоповтором.

>> Клавиши-модификаторы: event.shiftKey - клавиша Shift         | - true, если нажаты во время срабатывания события
                         event.altKey   - клавиша Alt           |
                         event.ctrlKey  - клавиша Ctrl          |
                         event.metaKey  - клавиша Cmd для Mac   |

>> event.key - символ нажатой клавиши (буква, цифра, Enter, Tab, F1 и т.д.).
>> event.code - код нажатой клавиши (Key<буква>, Digit<цифра>, Enter, Tab, F1 и т.д.).

>> Делегирование событий - один обработчик на общего предка обрабатываемых элементов.
      Способы делегирования: 
            1. Простые проверки
            2. Атрибуты data- (этот способ называют "behavior" (поведение))

>> Создание пользовательских событий:
      1. new CustomEvent(type, options) - лучший способ для пользовательских событий
            > type - строка с названием события.
            > options === {
                  bubbles: true/false    - всплытие разрешить/запретить
                  cancelable: true/false - отмену события по умолчанию разрешить/запретить
                  composed: true/false   - всплытие за пределы Shadow DOM разрешить/запретить 
                  detail: { ... }        - объект для передачи любых пользовательских данных обработчику событий
            }

      2. new Event(type, options) - как CustomEvent, только без свойства detail в options.
      3. Конструкторы различных UI Event: UIEvent, FocusEvent, MouseEvent, WheelEvent, KeyboardEvent, ...

>> elem.dispatchEvent(event) - запускает объект-событие event на elem. 
                               Возвращает false, если какой-либо обработчик события вызвал event.preventDefault().

>> В событиях 'mouseover'/'mouseenter': event.target        - элемент, НА который курсор перешел.
                                        event.relatedTarget - элемент, С которого курсор ушел (может быть null).

>> В событиях 'mouseout'/'mouseleave': event.target - элемент, С которого курсор ушел.
                                       event.relatedTarget - элемент, НА который курсор перешел (может быть null).

>> В событиях 'mouseover'/'mouseout' курсор всегда над самым глубоко вложенным элементом.

>> События 'mouseenter'/'mouseleave' как 'mouseover'/'mouseout', но: 1. Не срабатывают на children;
                                                                     2. Не всплывают (невозвожно делегирование).
                                    
>> Событие 'scroll' срабатывает при прокрутке страницы.
                        
>> document.elementFromPoint(clientX, clientY) - возвращает наиболее глубоко вложенный элемент по заданным координатам.

>> Базовый алгоритм Drag'n'Drop:
      1. Подготовить к перемещению элемент :
            - mousedown
            - ondragstart return false
            - position absolute
            - z-index 1000
      2. Перемещать элемент:
            - mousemove
            - left top event.pageX evemt.pageY
      3. Если нужно, узнать, над каким элементом (droppable) в данный момент находится переносимый элемент (draggable)
            - elem.hidden true -> elemBelow document.elementFromPoint -> elem.hidden false
      4. Остановить перенос:
            - mouseup
            - removeEventListener mousemove mouseup

>> Свойства Pointer Events:
      1. Свойства, что и у Mouse Events.
      2. pointerId - id указателя, который вызвал событие (число генерируется движком).
      3. pointerType - тип указателя. Строковое значение: 'mouse'/'pen'/'touch'.
      4. isPrimary === true для основного (1-го) указателя, который вызвал событие.
      5. width/height - ширина/высота области соприкосновения указателя с устройством. === 1, если не поддерживается устройством.
      6. pressure - степень давления указателя в диапазоне от 0 до 1. === 0.5, если не поддерживается устройством.
      7. tangentialPressure - нормализованное тангенциальное давление.
      8. tiltX/tiltY/twist - положение пера относительно сенсорной поверхности.

>> События указателя (Pointer Events) аналогичны Mouse Events: 'pointer<событие>' аналог 'mouse<событие>'.
      
>> Событие указателя 'pointercancel' - срабатывает, когда действие с указателем прерывается 
                                       и события указателя больше не генерируются. 
                                       Причины срабатывания 'pointercancel':
                                          - выключение устройства
                                          - нажатие кнопки "Home"
                                          - смена ориентации устройства в пространстве
                                          - сработало событие по умолчанию
                                          - превышение максимально допустимого количества нажатий на экран
                                          - движок решил, что нажатие вызвано случайно
                                          
>> Событие 'gotpointercapture' - срабатывает при захвате указателя (setPointerCapture).
>> Событие 'lostpointercapture' - срабатывает при освобождении от захвата указателя (pointerup, pointercancel, releasePointerCapture).

>> { touch-action: none; } - CSS-свойство, чтобы предотвратить срабатывания события по умолчанию

>> elem.setPointerCapture(pointerId) - привязывает все дальнейшие Pointer Events с указанным pointerId к элементу.
                                       Захват указателя упрощает Drag'n'Drop.
                                       Освобождается от захвата при:
                                          1. Событии 'pointerup';
                                          2. Событии 'pointercancel';
                                          3. Удалении элемента из документа;
                                          4. Вызове elem.releasePointerCapture(pointerId).

+ Устаревшие события, методы и свойства
      event.which - возвращает номер кнопки мыши (0 - левая, 1 - средняя, 2 - правая и т.д.);
      event.keyCode - аналог event.key;
      'keypress' - срабатывает, когда нажимается клавиша создающая символ.


///////////
19. Jest  
///////////

Jest - фреймворк для тестирования JavaScript. Работает с ReactJS, NodeJS, Babel, TypeScript, Vue, Angular.

>> Цель автотестирования - проверка соответствия ПО предъявляемым требованиям.

>> Регрессионное тестирование - проверка целосности старого ПО, после внесения новых изменений.

>> Функциональное тестирование:
      > UNIT (модельное) - тест на отдельну независимую фу-ю, компонент.
      > Скриншотные тесты - сравнение старой и новой визуальной части (UI).
      > INTEGRATION (интеграционные) - взаимодействие нескольких фу-й или компонентов.
      > E2E (end-to-end) - полная функциональность частей приложения (регистрация, авторизация, оплата).

>> Expect-методы - сопоставляют фактический результат от ожидаемого.

>> Mock-функции - следят за поведением функций, которые используются сторонним кодом.


>> Методы:
      > mockFn.mockReturnValue(value) - возвращает value при каждом вызове mockFn

      > jest.mock(moduleName) - ?


////////////
20. Axios   
////////////

Axios - HTTP-клиент базирующийся на Promise для браузера и NodeJS (изоморфный).


/////////////
21. NodeJS
/////////////

>> Команды npm:
    > npm -h (--help)               // вызов справки
    > npm i  (install)              // устанавливает зависимости для проекта
    > npm i -D (install --save-dev) // устанавливает зависимости для разработки
    > npm t  (test)                 // запуск тестирование
    > npm -g (--global)             // флаг глобальной установки
    > npm init -y (--yes)           // принятие установок инициализации
    > npm init -f (--force)         // принятие установок инициализации
    > npm -O (--save-optional)      // сохранение пакета в виде опциональной зависимости
    > npm -E (--save-exact)         // сохранение сведений о точной версии пакета
    > npm -B (--save-bundle)        // записывает в package.json в bundleDependencies список установленных пакетов
    > npm pack                      // создает tarball-файл, содержащий файлы проекта и пакеты из bundleDependencies

>> Node.js - среда выполнения кода JavaScript:
    - на основе JS Chrome V8
    - позволяет выполнять JS вне веб-браузера
    - предназначен для создания серверных приложений
    - хорошо подходит для обработки потоковых данных в реальном времени
    - НЕ подходит для решения задач, требующих много ресурсов

>> Особенности Node.js:
    1. global
    2. Нет взаимодействия с DOM
    3. Есть доступ к файловой системе клиента       

>> Node REPL - интерактивный интерпретатор (Read-Evaluate-Print-Loop)

>> Встроенные модули Node.js:
    - path
    - http
    - js (можно работать через Promise)
    - os
    - crypto
    
>> runtime - означает запущенный процесс в ОЗУ, который откликается на команды

>> LibUV - библиотека на C++, которая обеспечивает поддержку неблокирующих операций ввода-вывода
>> C++ Bindings - термин выделяющий группу библиотек (посредники), которые позволяют использовать в Node.js функционал библиотеки LibUV
>> Thread Scheduler (Планировщик потоков) - часть ОС, которая отвечает за паралельное выполнение задач

>> worker_threads - модуль в Node.js позволяющий управлять потоками из кода

>> Демультиплексор событий - собирает и ставит в очередь события I/O

>> Принцип работы шаблона REACTOR:
    Приложение[I/O <--> Обработка] --> Демультиплексор событий --> Очередь событий --> Event Loop <--> Приложение

>> Processes and threads (процессы и потоки):
    1. Node.js имеет  1 поток, который обрабатывает все запросы
    2. LibUV обеспечивает поддержку многопоточных операций (ассинхронные неблокирующие операции)

>> LibUV: 1. Event loop - асинхронно обрабатывает событийные операции (вызываются фу-и подписанные на события)
          2. Thread pool - асинхронно обрабатывает операции из основного потока кода:
              - по умолчанию 4 threads
              - максимум 1024 threads

>> Этапы выполнения событий в Event loop:
    1. process.nextTick ( метод, который вызывает любой callback немедленно, независимо от этапа event loop )
    2. Promise
    3. Timers ( setTimeout, setInterval )
    4. Pending ( Input/Output callbacks отложенные до след. итерации event loop)
    5. Idle, Prepare ( внутренние служебные задачи Node.js )
    6. Poll ( event loop получает и выполняет задачи Input/Output )
    7. Check ( setImmediate )
    8. Close ( close event callbacks )
    9. Продолжать ли event loop? ( если нет, то выход из цикла )

>> Этапы выполнения событий в Event loop (Упрощенная схема):
    1. process.nextTick <---┐
    2. Promise              |
    3. Timers               |
    4. I/O Events           |  
    5. Check                |
    6. Close ---------------┴---> Выход из Event loop  
    
>> Способы экспорта сущностей:
    1. module.exports.foo = foo
    2. module.exports.foo = function () {}
    3. module.exports = function () {}      // экспорт по умолчанию

>> Внутреннее устройство модуля в Node.js (common.js):
    (function (exports, require, module, __filename, __dirname) {
        console.log(arguments.callee.toString())
    })

>> Streams (потоки):
    - Readable
    - Writable
    - Duplex (Readable + Writable)
    - Transform (как Duplex, но может изменять данные по мере чтения)


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
* * *   Полезный софт   * * *   
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

------------------------------------
* 1. Cache-Wrapper + call + apply 
------------------------------------
let workers = {
   someProp: 10,
    
   someMethod(arg1, arg2) {
   return arg1 + arg2 + this.someProp
   },
}

workers.someMethod = cachingDecorator(workers.someMethod, hash)
    
function hash() {
   return [].join.call(arguments)
}
    
function cachingDecorator(func, hash) {
   let cache = new Map()
    
   return function (...args) {
      let key = hash(arguments)
   
      if (cache.has(key)) return cache.get(key)
    
      let result = func.apply(this, args)
    
      cache.set(key, result)
    
      return result
   }
}

console.log(workers.someMethod(1, 2))


------------------------------------------------------
* 2. Object.prototype.toString - расширенный typeof
------------------------------------------------------

let objToString = Object.prototype.toString

let user           = { [Symbol.toStringTag]: 'User' }       
let array          = []                                     
let number         = 123                                    
let string         = 'str'                                  
let boolean        = true                                   
let nullValue      = null                                   
let functionValue  = alert                                  
let undefinedValue = undefined                              

objToString.call(user)              // [object User]    
objToString.call(array)             // [object Array]
objToString.call(number)            // [object Number]
objToString.call(string)            // [object String]
objToString.call(boolean)           // [object Boolean]
objToString.call(nullValue)         // [object Null]
objToString.call(functionValue)     // [object Function]
objToString.call(undefinedValue)    // [object Undefined]


------------------------------
* 3. Обёртывание исключений
------------------------------

class ReadError extends Error {
      constructor(message, cause) {
        super(message)
        this.cause = cause
        this.name = 'ReadError'
      }
}
    
class ValidationError extends Error {
      constructor(message) {
            super(message)
            this.name = this.constructor.name
      }
}
    
class PropertyRequiredError extends ValidationError {
      constructor(property) {
            super('Absent property: ' + property)
            this.property = property
      }
}
    
function readUser(json) {
      let user
    
      try {
            user = JSON.parse(json)
      } catch (error) {
            if (error instanceof SyntaxError) throw new ReadError(error.name, error)
            else throw error
      }
    
      try {
            validateUser(user)
      } catch (error) {
            if (error instanceof ValidationError) throw new ReadError(error.name, error)
            else throw error
      }
}
    
function validateUser(user) {
      if (!user.age) throw new PropertyRequiredError('age')
      if (!user.name) throw new PropertyRequiredError('name')
    
      return user
}
    
try {
      readUser('{ "name": "k", "age": 25 }')
} catch (error) {
      if (error instanceof ReadError) {
            console.log(`${error.name}: ${error.cause}`)
      } else throw error
}


----------------------
* 4. Промисификация   
----------------------

function promisify(fn, manyArgs = false) {
      return function (...args) {
            return new Promise((resolve, reject) => {
                  function callback(error, ...results) {
                        if (error) reject(error)
                        else resolve(manyArgs ? results : results[0])
                  }
    
                  args.push(callback)
    
                  fn.call(this, ...args)
            })
      }
}
    
fn = promisify(fn, true)
fn(...).then(arrayOfResults => {...}, error => {...})
